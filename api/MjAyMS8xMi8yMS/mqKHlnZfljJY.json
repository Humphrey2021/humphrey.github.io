{"title":"模块化","date":"2021-12-21T13:11:58.000Z","date_formatted":{"ll":"Dec 21, 2021","L":"12/21/2021","MM-DD":"12-21"},"link":"2021/12/21/模块化","tags":["javascript","模块化"],"categories":["前端"],"updated":"2021-12-22T12:30:37.407Z","content":"<h3 id=\"模块，模块化开发，规范\">模块，模块化开发，规范<a title=\"#模块，模块化开发，规范\" href=\"#模块，模块化开发，规范\"></a></h3>\n<ol>\n<li>模块化开发的目标是把程序拆分成一个个小<strong>结构</strong></li>\n<li>在当前的<strong>结构</strong>中可以编写自己的逻辑代码，他拥有自己的作用域，不会影响到其他<strong>结构</strong></li>\n<li>在某个<strong>结构</strong>中可以向外界暴露自己的变量、函数、对象等给其他<strong>结构</strong>进行使用</li>\n<li>在其他<strong>结构</strong>中如果需要使用别的<strong>结构</strong>的数据，则需要进行导入</li>\n</ol>\n<p>那么这些个<strong>结构</strong>就是<strong>模块</strong><br>\n基于这种模式的开发就是<strong>模块化开发</strong><br>\n这个导入导出则就是<strong>模块化规范</strong></p>\n<h3 id=\"为什么需要模块化？\">为什么需要模块化？<a title=\"#为什么需要模块化？\" href=\"#为什么需要模块化？\"></a></h3>\n<p>随着前端的发展，业务越来越复杂，特别是从 SPA 应用的出现后，前端所需要编写的代码量越来越大，所以为了方便管理项目，则需要对项目进行拆分，从而也就需要模块化</p>\n<h3 id=\"commonjs-和-node\">CommonJS 和 Node<a title=\"#commonjs-和-node\" href=\"#commonjs-和-node\"></a></h3>\n<ol>\n<li>CJS实现了在非浏览器环境中运行js代码</li>\n<li>NodeJs就是CJS的经典实现</li>\n</ol>\n<h3 id=\"module.exports、exports-和-require\">module.exports、exports 和 require<a title=\"#module.exports、exports-和-require\" href=\"#module.exports、exports-和-require\"></a></h3>\n<h4 id=\"module.exports\">module.exports<a title=\"#module.exports\" href=\"#module.exports\"></a></h4>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = obj</span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;a.js&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"exports\">exports<a title=\"#exports\" href=\"#exports\"></a></h4>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">exports</span> = obj <span class=\"comment\">// 方式1 --- 错误写法</span></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.obj = obj <span class=\"comment\">// 方式2 --- 固定用法</span></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;a.js&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// 方式1： &#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj) <span class=\"comment\">// 方式2：&#123; obj: &#123; a: 1, b: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在 Node 的内部实现中, 有下面两行代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports</span><br></pre></td></tr></table></figure>\n<p>由此可以看出，module.exports 是创建了一个对象，并指向了这个对象，exports = module.exports 操作就让exports同样指向了这个对象，但如果我们做了 exports = obj 这种操作， 相当于是对这个对象进行了重新赋值，指向了一个新对象，那就不对了。</p>\n<h4 id=\"require-规则\">require 规则<a title=\"#require-规则\" href=\"#require-规则\"></a></h4>\n<ol>\n<li>require(‘fs’) 等<br>\n加载核心模块，直接去查找</li>\n<li>require(‘./xxx’) 传入路径形式\n<ul>\n<li>require(‘./xxx.js’) 带后缀名<br>\n在对应目录查找对应文件</li>\n<li>require(‘./xxx’) 传入路径形式，不带后缀的<br>\n先去查找 xxx 文件，没有会进行后缀补全，优先级：.js --&gt; .json --&gt; .node</li>\n<li>如果都没有找到，则会将 xxx 当作目录，查找当前目录下的 index 文件，没有则会继续进行后缀补全，index.js --&gt; index.json --&gt; index.node</li>\n<li>如果上述全部都没有找到，则就会报错了</li>\n</ul>\n</li>\n<li>require(‘axios’) 非路径，非核心模块\n<ul>\n<li>会将其当作第三方模块进行查找</li>\n<li>从当前文件所在目录一级一级向上查找 node_modules，一直找到根目录</li>\n</ul>\n</li>\n<li>当多次导入一个文件</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;1234&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">6</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>) <span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>当多次导入一个文件的时候，该文件内的代码只会执行一次，因为会被缓存下来<br>\n5. require() 是同步的加载模式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>) <span class=\"comment\">// 在执行到这行时，会停住，直到这个文件内的代码走完以后才会去执行下面的代码</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;aaa&#x27;</span>)</span><br></pre></td></tr></table></figure>\n","next":{"title":"手写Promise源码","link":"2021/12/16/手写Promise源码"},"plink":"https://rdhuang.gitee.io/2021/12/21/模块化/","toc":[{"id":"模块，模块化开发，规范","title":"模块，模块化开发，规范","index":"1"},{"id":"为什么需要模块化？","title":"为什么需要模块化？","index":"2"},{"id":"commonjs-和-node","title":"CommonJS 和 Node","index":"3"},{"id":"module.exports、exports-和-require","title":"module.exports、exports 和 require","index":"4"}],"copyright":{"author":"Humphrey","link":"<a href=\"https://rdhuang.gitee.io/2021/12/21/模块化/\" title=\"模块化\">https://rdhuang.gitee.io/2021/12/21/模块化/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}