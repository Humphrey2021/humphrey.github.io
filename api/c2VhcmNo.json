[{"title":"函数式编程","date":"2021-11-30T14:25:34.000Z","date_formatted":{"ll":"Nov 30, 2021","L":"11/30/2021","MM-DD":"11-30"},"updated":"2021-11-30T14:26:01.761Z","content":"\n函数式编程概念\n函数式编程（Functional Programming, FP）是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。\n它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 就是对运算过程进行抽象，函数式编程中函数指的不是程序中的函数（方法），而是数学中的函数即映射关系。\n123456789101112// 非函数式编程let num1 = 1let num2 = 2let sum = num1 + num2console.log(sum)// 函数式function add (n1, n2) &#123;    return n1 + n2&#125;let sum = add(1, 2)console.log(sum)\n函数式编程的特性\n\n\n函数是“第一等公民（first class）”\n&quot;第一等公民&quot;指的是函数与其他数据类型一样，处于平等地位,可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n\n函数可以赋值给其他变量\n\n  1234567891011121314const fn = () =&gt; &#123;    console.log(&#x27;我可以存储在变量中&#x27;)&#125;fn()// 示例const obj = &#123;    index (posts) &#123; return Views.index(posts) &#125;&#125;// 优化const obj = &#123;    index: Views.index&#125;\n\n\n高阶函数(Higher-order function)\n\n可以把函数作为参数传递给另一个函数\n\n  12345678// forEachconst forEach = (array, fn) =&gt; &#123;    for (let i = 0; i &lt; array.length; i ++) &#123;        fn(array[i])    &#125;&#125;let arr = [1, 2, 3, 4, 5]forEach(arr, i =&gt; &#123; console.log(i) &#125;)\n\n可以把函数作为另一个函数的返回结果\n\n  1234567891011121314const once = fn =&gt; &#123;    let flag = false    // 注意：这里返回的函数如果写成箭头函数的话，会找不到 this    return function () &#123;        if (!flag) &#123;            flag = true            return fn.apply(this, arguments)        &#125;    &#125;&#125;const pay = once(money =&gt; &#123; console.log(`支付了$&#123;money&#125;元`) &#125;)pay(5)pay(5)pay(5)\n\n\n闭包(Closure)\n函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包\n\n\n可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员\n\n\n本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n\n  1234567891011121314// 案例function makePower (power) &#123;    return function (number) &#123;        return Math.pow(number, power)    &#125;&#125;// 优化写法const makePower = power =&gt; num =&gt; Math.pow(num, power)let power2 = makePower(2) // 求平方let power3 = makePower(3) // 求立方console.log(power2(2))console.log(power2(3))console.log(power3(2))\n\n\n纯函数\n\n相同的输入永远会得到相同的输出, 而且没有任何可观察的副作用\n\n  123456789let arr = [1, 2, 3, 4, 5]// 纯函数console.log(arr.slice(0, 3)) // [1, 2, 3]console.log(arr.slice(0, 3)) // [1, 2, 3]// 不纯函数console.log(arr.splice(0, 3)) // [1, 2, 3]console.log(arr.splice(0, 3)) // [4, 5]console.log(arr.splice(0, 3)) // []\n\n\n惰性计算\n在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。\n\n\n递归\nFP 还有一个特点是用递归做为控制流程的机制。\n\n\n只用&quot;表达式&quot;，不用&quot;语句&quot;\n\n\n没有&quot;副作用&quot;\n所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n\n\n不修改状态\n函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。\n\n\n引用透明性\n函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。\n\n\n副作用\n副作用是修改系统状态的语言结构。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。\n\n\n函数式编程的优点\n\n代码简洁，开发快速\n接近自然语言，易于理解\n更方便代码管理\n易于“并发编程”\n代码的热升级\n\n","plink":"https://rdhuang.gitee.io/2021/11/30/函数式编程/"}]