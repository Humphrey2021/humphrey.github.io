[{"title":"checkLogin","date":"2021-12-11T14:10:26.000Z","date_formatted":{"ll":"Dec 11, 2021","L":"12/11/2021","MM-DD":"12-11"},"updated":"2021-12-11T14:57:51.632Z","content":"登录逻辑\nlogin.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// 判断是否是手机银行环境const isBank = true// 路由登录拦截 checkLogin// 在router.js 里面的 beforeEnter: CheckLogin 的逻辑// 排除几个只需要静默登录，不在乎成功失败的页面（即：不会跳转登录的页面）const noToLoginPages = [&#x27;/home&#x27;, &#x27;/order&#x27;, &#x27;/detail&#x27;]const CheckLogin = async (to, from, next) =&gt; &#123;    console.log(&#x27;CheckLogin&#x27;, to, from)    try &#123; // 做一个约定，只有信任登录成功才会走到这，直接进入下一个页面，否则一切都走到 catch 里面，做登录失败的处理        let res = await CifCheckLogin(to.query) // 信任登录        if (res === &#x27;next&#x27;) next()    &#125; catch (err) &#123;        // 这里需要先排除那些只信任登录，不在乎成功失败的页面        console.log(&#x27;信任登录失败原因：&#x27;, err) // 这里是reject的值---没有信任登录成功的处理        if (noToLoginPages.includes(to.path)) &#123;            next()        &#125; else &#123;            // 除此之外,如果是接口错误，返回首页，如果是状态不对，跳转登录            err.action === &#x27;toLogin&#x27; ? toLogin(to, from, next) : next(&#x27;/&#x27;)        &#125;    &#125;&#125;/** * 信任登录 */function CifCheckLogin(query) &#123;    console.log(&#x27;CifCheckLogin----query&#x27;, query)    return new Promise((resolve, reject) =&gt; &#123;        // 如果登录过，并且是成功状态，直接进入下一页        if (sessionStorage.getItem(&#x27;webloginCode&#x27;) == 1) resolve(&#x27;next&#x27;)        // 如果有过主动退出，应该直接跳转登录页面        if (sessionStorage.getItem(&#x27;logOut&#x27;)) reject(&#123; action: &#x27;toLogin&#x27;, message: &#x27;主动退出过，存在logOut&#x27; &#125;)        // 如果在手机银行环境中        if (isBank) &#123;            // 判断地址栏参数，如果存在 mac 即需要 TRUST 登录            if (query &amp;&amp; query.mac) &#123;                // 这里需要请求 webLogin 接口                webloginApi(&#x27;TRUST&#x27;, to.query, resolve, reject)            &#125; else &#123;                // 如果没有参数，调手机银行插件信任登录                window.Plugin.xxx((cifid, unifinedId) =&gt; &#123;                    if (!cifid &amp;&amp; !unifinedId) &#123;                        reject(&#x27;toLogin: noCifId &amp; noUnifinedId&#x27;)                    &#125;                    // 这里需要对参数进行加密                    this.utils.sm2(query).then(smData =&gt; &#123;                        webloginApi(&#x27;CIF&#x27;, smData, resolve, reject)                    &#125;)                &#125;)            &#125;        &#125; else &#123;            // 如果是非手机银行环境，判断地址栏是否有 token，再去请求 webLogin 接口            query &amp;&amp; query.token ? webloginApi(&#x27;UNIFINED&#x27;, to.query, resolve, reject) : reject(&#123; action: &#x27;toLogin&#x27;, message: &#x27;手机银行缓存没有cifid以及unifinedId&#x27; &#125;)        &#125;    &#125;)&#125;// 调用weblogin接口const webloginApi = async (loginType, data, resolve, reject) =&gt; &#123;    console.log(&#x27;webloginApi--Data: &#x27;, &#123; loginType, ...data &#125;)    try &#123;        let res = await this.$api.user.weblogin(&#123; loginType, ...data &#125;)        handleLoginData(res, resolve, reject)    &#125; catch (err) &#123;        reject(&#123; action: &#x27;toHome&#x27;, message: err &#125;)    &#125;&#125;// 处理 weblogin 接口返回值const handleLoginData = (res, resolve, reject) =&gt; &#123;    console.log(&#x27;returnLoginData:&#x27;, res)    sessionStorage.setItem(&#x27;webloginCode&#x27;, res.returnCode)    if (res.returnCode === 1) &#123;        // 成功        successData(res.uto || res)        resolve(&#x27;next&#x27;)    &#125; else &#123;        // 除了 1 以外的所有情况都属于失败        ErrorData(res, reject)    &#125;&#125;const successData = data =&gt; &#123;    // 处理成功登录的一系列操作    // 存储 token ，user ，啥啥啥的。    // 登录成功需要清除主动退出标识 logOut&#125;const ErrorData = (data, reject) =&gt; &#123;    // 判断状态码； 不同的状态码对应不同的情况，有些需要弹窗，有些需要啥啥的    // 不管哪样，这些都属于失败，那么就需要把 存在的一切登录信息清除掉    // 如果是账号被顶，需要主动添加 主动退出标识 logOut    clearLoginData()    switch (data.returnCode) &#123;        case 2:            // 啥啥啥            reject(&#123; action: &#x27;toLogin&#x27;, message: &#x27;weblogin接口返回 2&#x27; &#125;)            break;        case -1:            // 啥啥啥            reject(&#123; action: &#x27;toLogin&#x27;, message: &#x27;weblogin接口返回 -1&#x27; &#125;)            break;        case xx:            // 啥啥啥            break;    &#125;&#125;// 清除登录信息const clearLoginData = () =&gt; &#123;    // localStorage.removeItem(&#x27;user&#x27;, &#x27;token&#x27;, ...)    // ...clear    // 还需要 清除一下 手机银行的登录信息    // 调手机银行登出插件做一个登出操作--控制台好像容易报错，需要对这个插件做一个容错处理&#125;// 跳转登录// 这里需要有两种情况， 登录成功之后的返回// 1. 路由跳转的登录    2. 接口触发的登录跳转const toLogin = (to, from, next) =&gt; &#123;    console.log(&#x27;toLogin----&#x27;, &#x27;to:&#x27;, to, &#x27;from:&#x27;, from)    // 接口触发的话，to 和 from，相同就行，成功，失败，返回后退，都是在当前页面    if (isBank) &#123;        // 插件登录        // 成功之后        // 如果是路由触发        next() // 成功        next(from) // 失败,或者返回        // 需要考虑，插件登录，成功之后会不会刷新页面        // 刷新页面或不刷新怎么去处理    &#125; else &#123;        // 统一用户登录    &#125;&#125;","plink":"https://rdhuang.gitee.io/2021/12/11/checkLogin/"},{"title":"JavaScript异步编程","date":"2021-12-02T12:12:38.000Z","date_formatted":{"ll":"Dec 2, 2021","L":"12/02/2021","MM-DD":"12-02"},"updated":"2021-12-11T11:59:38.766Z","content":"JS异步编程的介绍\n首先说说为什么会有JS异步编程\n众所周知，JS是单线程模式工作的，因为JS是运行在浏览器端的脚本语言，目的是为了实现页面的交互，那么因为页面交互主要是DOM操作，从而决定了它必须使用单线程模式工作，否则就会出现特别复杂的线程同步问题。\n这种模式优点是更安全、更简单，缺点就是如果在代码执行中遇到一个特别耗时的操作，那么后面的代码就必须等待这个操作结束以后才可以执行。\n所以，为了解决像这样的情况，JS将任务的执行模式分成了两种，分别是同步模式(Synchronous)和异步模式(Asynchronous)\n同步模式和异步模式\n\n同步模式\n\n123456789101112131415console.log(&#x27;global begin&#x27;)function bar () &#123;    console.log(&#x27;bar&#x27;)&#125;function foo() &#123;    console.log(&#x27;foo&#x27;)    bar()&#125;foo()console.log(&#x27;global end&#x27;)// global begin// foo// bar// global end\n\n异步模式\n\n123456789101112131415161718console.log(&#x27;g1 begin&#x27;)setTimeout(function timer1() &#123;    console.log(&#x27;timer1&#x27;)&#125;, 1800) // 这里如果把时间改为 &gt;= 2000 则结果 timer1 会在 timer3 之后打印setTimeout(function timer2() &#123;    console.log(&#x27;timer2&#x27;)    setTimeout(function timer3() &#123;        console.log(&#x27;timer3&#x27;)    &#125;, 1000)&#125;, 1000)console.log(&#x27;g1 end&#x27;)// g1 begin// g1 end// timer2// timer1// timer3\n回调函数\n所有异步编程方案的根基\nPromise\n123456789101112131415161718192021222324252627282930function ajax (url) &#123;    return new Promise(function (resolve, reject) &#123;        let xhr = new XMLHttpRequest()        xhr.open(&#x27;GET&#x27;, url)        xhr.responseType = &#x27;json&#x27;        xhr.onload = function () &#123;            if (this.status === 200) &#123;                resolve(this.response)            &#125; else &#123;                reject(new Error(this.statusText))            &#125;        &#125;        xhr.send()    &#125;)&#125;// 方案一ajax(&#x27;/api/urls.json&#x27;)    .then(function onFulfilled(res) &#123;        console.log(&#x27;onFulfilled&#x27;, res)    &#125;, function onRejected (err) &#123;        console.log(&#x27;onRejected&#x27;, err)    &#125;)// 方案二ajax(&#x27;/api/urls.json&#x27;)    .then(function onFulfilled(res) &#123;        console.log(&#x27;onFulfilled&#x27;, res)    &#125;)    .catch(function onRejected (err) &#123;        console.log(&#x27;onRejected&#x27;, err)    &#125;)\n全局捕获异常*\n\nunhandledrejection\n\n1234567891011121314// 在浏览器上window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt; &#123;    const &#123; reason, promise &#125; = event    console.log(reason, promise)    // reason =&gt; Promise 失败原因，一般是一个错误对象    // promise =&gt; 出现异常的 Promise 对象    event.preventDefault()&#125;, false)// 在 node 上process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; &#123;    console.log(reason, promise)    // reason =&gt; Promise 失败原因，一般是一个错误对象    // promise =&gt; 出现异常的 Promise 对象&#125;)\n\n事件循环和消息队列\n异步编程的几种方式\nPromise异步方案、宏任务/微任务队列\nGenerator异步方案、Async/Await语法糖\n","plink":"https://rdhuang.gitee.io/2021/12/02/JavaScript异步编程/"},{"title":"函数式编程","date":"2021-11-30T15:45:00.000Z","date_formatted":{"ll":"Nov 30, 2021","L":"11/30/2021","MM-DD":"11-30"},"updated":"2021-12-08T09:06:59.839Z","content":"\n函数式编程概念\n函数式编程（Functional Programming, FP）是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。\n它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 就是对运算过程进行抽象，函数式编程中函数指的不是程序中的函数（方法），而是数学中的函数即映射关系。\n123456789101112// 非函数式编程let num1 = 1let num2 = 2let sum = num1 + num2console.log(sum)// 函数式function add (n1, n2) &#123;    return n1 + n2&#125;let sum = add(1, 2)console.log(sum)\n函数式编程的特性\n\n\n函数是“第一等公民（first class）”\n&quot;第一等公民&quot;指的是函数与其他数据类型一样，处于平等地位,可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n\n函数可以赋值给其他变量\n\n  1234567891011121314const fn = () =&gt; &#123;    console.log(&#x27;我可以存储在变量中&#x27;)&#125;fn()// 示例const obj = &#123;    index (posts) &#123; return Views.index(posts) &#125;&#125;// 优化const obj = &#123;    index: Views.index&#125;\n\n\n高阶函数(Higher-order function)\n什么是高阶函数\n\n可以把函数作为参数传递给另一个函数\n\n  12345678// forEachconst forEach = (array, fn) =&gt; &#123;    for (let i = 0; i &lt; array.length; i ++) &#123;        fn(array[i])    &#125;&#125;let arr = [1, 2, 3, 4, 5]forEach(arr, i =&gt; &#123; console.log(i) &#125;)\n\n可以把函数作为另一个函数的返回结果\n\n  1234567891011121314const once = fn =&gt; &#123;    let flag = false    // 注意：这里返回的函数如果写成箭头函数的话，会找不到 this    return function () &#123;        if (!flag) &#123;            flag = true            return fn.apply(this, arguments)        &#125;    &#125;&#125;const pay = once(money =&gt; &#123; console.log(`支付了$&#123;money&#125;元`) &#125;)pay(5)pay(5)pay(5)\n使用高阶函数的意义\n\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n高阶函数是用来抽象通用的问题\n\n\n\n闭包(Closure)\n函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包\n\n\n可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员\n\n\n本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n\n  1234567891011121314// 案例function makePower (power) &#123;    return function (number) &#123;        return Math.pow(number, power)    &#125;&#125;// 优化写法const makePower = power =&gt; num =&gt; Math.pow(num, power)let power2 = makePower(2) // 求平方let power3 = makePower(3) // 求立方console.log(power2(2))console.log(power2(3))console.log(power3(2))\n\n\n纯函数\n\n相同的输入永远会得到相同的输出, 而且没有任何可观察的副作用\n\n  123456789let arr = [1, 2, 3, 4, 5]// 纯函数console.log(arr.slice(0, 3)) // [1, 2, 3]console.log(arr.slice(0, 3)) // [1, 2, 3]// 不纯函数console.log(arr.splice(0, 3)) // [1, 2, 3]console.log(arr.splice(0, 3)) // [4, 5]console.log(arr.splice(0, 3)) // []\n\n\n惰性计算\n在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。\n\n\n不修改状态\n函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。\n\n\n没有&quot;副作用&quot;\n所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。\n\n\n函数式编程的优点\n\n代码简洁，开发快速\n接近自然语言，易于理解\n更方便代码管理\n易于“并发编程”\n代码的热升级\n\n函数式编程基础\nlodash\nlodash（中文官网、英文官网）是一个一致性、模块化、高性能的 JavaScript 实用工具库\n\n安装\n\n1npm install lodash\n\n引入\n\n1const _ = require(&#x27;lodash&#x27;)\n\n使用\n\n123456789const array = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;]console.log(_.first(array)) // red console.log(_.last(array)) // pinkconsole.log(_.toUpper(_.first(array))) // REDconsole.log(_.reverse(array) // [&#x27;pink&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;red&#x27;]_.each(array, (v, i) =&gt; &#123;    console.log(v, i) // red 0  green 1  yellow 2  pink 3&#125;)\n纯函数\n\n可缓存\n\n因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\n\n  1234567891011121314151617181920// 记忆函数 const _ = require(&#x27;lodash&#x27;)function getArea (r) &#123;    console.log(r, &#x27;我只会执行一次，因为我被缓存起来了&#x27;)    return Math.PI * r * r&#125;let getAreaWithMemory = _.memoize(getArea)console.log(getAreaWithMemory(4))console.log(getAreaWithMemory(4))console.log(getAreaWithMemory(4))// 模拟实现function myMemoize(fn) &#123;    let cache = &#123;&#125;    return function () &#123;        let key = JSON.stringify(arguments)        cache[key] = cache[key] || fn.apply(fn, arguments)        return cache[key]    &#125;&#125;\n\n可测试\n\n纯函数可以让测试更方便\n\n\n并行处理\n\n在多线程环境下，并行操作共享的内存数据很可能会出现意外情况\n纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(Web Worker)\n\n\n\n函数柯里化\n\n在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n1234567// 简单的举例const add = (a, b) =&gt; a + b// Currying 后const curryingAdd = a =&gt; b =&gt; a + badd(1, 2) // 3curryingAdd(1)(2) // 3\n由此可以看出，柯里化一个函数，就是把原可以接收多个参数的函数变换成只接收单一参数，并用返回的函数接收余下的参数且返回结果的技术。\n1234567891011121314151617181920// 例：判断年龄基准值function checkAge (min, age) &#123;    return age &gt;= min&#125;// Currying 后function checkAge (min) &#123;    return function (age) &#123;        return age &gt;= min    &#125;&#125;// ES6 写法let checkAge = min =&gt; (age =&gt; age &gt;= min)let checkAge18 = checkAge(18)let checkAge20 = checkAge(20)checkAge18(16) // falsecheckAge18(20) // truecheckAge20(18) // falsecheckAge20(22) // true\n12345678910111213141516171819// 模拟实现 lodash 中的 curry 方法 （传入一个函数，把该函数转换为柯里化函数）const curry = fn =&gt; &#123;    return function curriedFn(...args) &#123;        if (args.length &lt; fn.length) &#123;            return function () &#123;                return curriedFn(...args.concat(Array.from(arguments)))            &#125;        &#125;        return fn(...args)    &#125;&#125;const getSum = (a, b, c) =&gt; (a + b + c)const curried = curry(getSum)curried(1, 2, 3) // 6curried(1, 2)(3) // 6curried(1)(2, 3) // 6curried(1)(2)(3) // 6\n总结\n\n\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n\n\n这是一种对函数参数的‘缓存’\n\n\n让函数变得更灵活，让函数的粒度更小\n\n\n可以把多元函数转换成一元函数，可以组合使用，产生强大的功能\n\n\n12345678910111213141516171819面试题：// 实现一个add方法，使计算结果能够满足如下预期：// add(1)(2)(3) = 6;// add(1, 2, 3)(4) = 10;// add(1)(2)(3)(4)(5) = 15;const add = (...rest) =&gt; &#123;    const fn = (...args) =&gt; &#123;        rest.push(...args)        return fn    &#125;    fn.toString = () =&gt; rest.reduce((total, num) =&gt; total + num, 0)    return fn&#125;console.log(+add(1)(2)(3)) // 6console.log(+add(1, 2, 3)(4)) // 10console.log(+add(1)(2)(3)(4)(5)) // 15\n组合函数\n\n\n函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间的过程函数合并成一个函数\n\n\n函数组合默认是从右到左执行\n\n\n123456789101112131415161718192021// 实现一个组合函数function compose (...args) &#123;    return function (value) &#123;        return args.reverse().reduce(function (acc, fn) &#123;            return fn(acc)        &#125;, value)    &#125;&#125;// ES6改造一下const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)// 测试const fn1 = arr =&gt; arr.reverse()const fn2 = arr =&gt; arr[0]const fn3 = str =&gt; str.toUpperCase()const f = compose(fn3, fn2, fn1)// const f = compose(compose(fn3, fn2), fn1)// const f = compose(fn3, compose(fn2, fn1))console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])) // THREE\n\n函数组合要满足结合律(associativity)\n\n我们既可以把 a 和 b 组合，还可以把 b 和 c 组合，结果都是一样的\n1234// 结合律let f = compose(a, b, c)compose(compose(a, b), c) == compose(a, compose(b, c))// true\n\n组合函数的调试\n\n123456789const _ = require(&#x27;lodash&#x27;)// 需要写一个辅助函数做调试const trace = _.curry((tag, v) =&gt; &#123;    console.log(tag, v)    return v&#125;)// 将此辅助函数插入到组合函数中即可compose(a, trace(&#x27;我在b之后&#x27;)， b, trace(&#x27;我在c之后&#x27;), c)\nPoint Free模式\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数\n\n不需要指明处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数\n\n案例演示\n123456789101112// Hello World =&gt; hello_world// 非 Point Free 模式function f (str) &#123;    return str.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;)&#125;// Point Freeconst fp = require(&#x27;lodash/fp&#x27;)const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;_&#x27;), fp.toLower)console.log(f(&#x27;Hello World&#x27;)) // hello_world\n函子(Functor)\n什么是Functor?\n\n容器：包含值和值的变形关系（这个变形关系就是函数）\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以i运行一个函数对值进行处理（变形关系）\n\n总结\n\n函数式编程的运算不直接操作值，而是由函子完成\n函子就是一个实现了map契约的对象\n我们可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最终map方法返回一个包含新值的盒子（函子）\n\nFunctor\n12345678910111213141516171819202122232425262728class Container &#123;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return new Container(fn(this._value))    &#125;&#125;new Container(5)    .map(v =&gt; v + 1) // Container &#123; _value: 6 &#125;    .map(v =&gt; v * v) // Container &#123; _value: 36 &#125;// ============改============造============&gt;class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return Container.of(fn(this._value))    &#125;&#125;Container.of(5)    .map(v =&gt; v + 1) // Container &#123; _value: 6 &#125;    .map(v =&gt; v * v) // Container &#123; _value: 36 &#125;\nMayBe\n处理空值情况\n1234567891011121314151617class MayBe &#123;    static of(value) &#123;        return new MayBe(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return this.isNothing() ? MayBe.of(this._value) : MayBe.of(fn(this._value))    &#125;    isNothing () &#123;        return this._value === null || this._value === undefined    &#125;&#125;MayBe.of(null)    .map(v =&gt; v * v)    // MayBe &#123; _value: null &#125;\nEither\n\nEither 两者中的任何一个，类似与 if…else… 的处理\n异常会让函数变得不纯，Either 函子可以用来做异常处理\n\n12345678910111213141516171819202122232425262728293031class Left &#123;    static of (value) &#123;        return new Left(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return this    &#125;&#125;class Right &#123;    static of (value) &#123;        return new Right(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return Right.of(fn(this._value))    &#125;&#125;function parseJSON (str) &#123;    try &#123;        return Right.of(JSON.parse(str))    &#125; catch (e) &#123;        return Left.of(&#123; error: e.message &#125;)    &#125;&#125;parseJSON(&#x27;&#123; name: xxx &#125;&#x27;) // Left &#123; _value: &#123;error: &#x27;Unexpected token n in JSON at position 2&#x27;&#125; &#125;\nIO\n\nIO 函子中 _value 是一个函数，这里是把函数作为值来处理\nIO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作（惰性执行），让当前的操作变为纯的操作\n把不纯的操作交给调用者来处理\n\n123456789101112131415161718const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;    static of (value) &#123;        return new IO(function() &#123;            return value        &#125;)    &#125;    constructor (fn) &#123;        this._value = fn    &#125;    map (fn) &#123;        return new IO(fp.flowRight(fn, this._value))    &#125;&#125;let r = IO.of(process).map(p =&gt; p.execPath) // IO &#123; _value: [Function] &#125;r._value() // C:\\xxx\\xxx\\xxx\\xxx\nTask\n异步执行\n\n异步任务的实现过于复杂，我们使用folktale中的Task来演示\nfolktale一个标准的函数式编程库\n\n和 lodash、ramda不同的是，没有提供很多功能函数\n只提供了一些函数式处理的操作，例如：compose、curry等，一些函子 Task、Either、MayBe等\n\n\n\n1234567891011const &#123; compose, curry &#125; = require(&#x27;folktale/core/lambda&#x27;)const &#123; toUpper, first &#125; = require(&#x27;lodash/fp&#x27;)let f = curry(2, (x, y) =&gt; &#123;    return x + y&#125;)f(1, 2) // 3f(1)(2) // 3let fn = compose(toUpper, first)fn([&#x27;one&#x27;, &#x27;two&#x27;]) // ONE\nTask处理异步任务\n123456789101112131415161718const fs = require(&#x27;fs&#x27;)const &#123; task &#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile (filename) &#123;    return task(resolver =&gt; &#123;        fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;            if (err) resolver.reject(err)            resolver.resolve(data)        &#125;)    &#125;)&#125;readFile(&#x27;xxx.xx&#x27;) // 查找某一文件    .map(fn) // 可以对文件进行某些处理    .map(fn) // 可以对文件进行某些处理(可以进行多次处理)    .run() // 执行    .listen(&#123; // 监听        onRejected: err =&gt; console.log(err), // 失败        onResolved: value =&gt; console.log(value) // 成功    &#125;)\nPointed函子\n\nPointed 函子是实现 of 静态方法的函子\nof 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值）\n\n1234567class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    ...&#125;Container.of(6).map(v =&gt; v * v)\nMonad\n\nMonad 函子是可以变扁的 Pointed 函子， IO(IO(x)),解决嵌套的问题\n一个函子如果具有 join 和 of 两个方法，并遵守一些定律就是一个 Monad\n\n1234567891011121314151617181920212223242526272829303132333435const fs = require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;    static of (value) &#123;        return new IO(function() &#123;            return value        &#125;)    &#125;    constructor (fn) &#123;        this._value = fn    &#125;    map (fn) &#123;        return new IO(fp.flowRight(fn, this._value))    &#125;    join () &#123;        return this._value()    &#125;    flatMap (fn) &#123;        return this.map(fn).join()    &#125;&#125;let readFile = function (filename) &#123;    return new IO(function () &#123;        return fs.readFileSync(filename, &#x27;utf-8&#x27;)    &#125;)&#125;let print = function (x) &#123;    return new IO(function() &#123;        console.log(x)        return x    &#125;)&#125;readFile(&#x27;xxxx.xx&#x27;).faltMap(print).join()\n","plink":"https://rdhuang.gitee.io/2021/11/30/函数式编程/"}]