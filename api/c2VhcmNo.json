[{"title":"Yeoman入门--实现属于自己的脚手架","date":"2022-01-15T05:37:52.000Z","date_formatted":{"ll":"Jan 15, 2022","L":"01/15/2022","MM-DD":"01-15"},"updated":"2022-01-16T09:27:37.913Z","content":"脚手架工具开发\n\n脚手架的本质作用就是为了创建项目的基本结构，提供项目的规范和约定\n一切技术都是为了解决问题而存在的。\n我们在不同的项目中，可以会存在很多相同的地方，如：组织结构、开发范式、模块依赖、工具配置、基础代码。为了方便，避免做太多重复操作，所以就出现了脚手架。\n\n目前常用的脚手架工具\nreact   ==&gt;  creat-reate-app\nvue     ==&gt;  vue-cli\nangular ==&gt;  angular-cli\n但今天我们要说说另外一种【Yeoman】，这是一款通用型的脚手架\nYeoman\n&lt; THE WEB’S SCAFFOLDING TOOL FOR MODERN WEBAPPS &gt;\n可以搭配不同的Generator去生成不同的项目\n基本使用\n\n第一步当然是安装了，但在安装之前需要检查是否安装了node和npm\n\n123456node -vnpm -v# 因为比较习惯用 yarn，后续代码也是使用yarn去代替npmyarn -v# 安装 yeomanyarn global add yo\n前面说了yeoman需要搭配不同的Generator去生成项目\n\n安装generator模块\n这里以node为例\n\n1yarn global add generator-node\n\n运行generator生成项目\n\n123# 运行generator就是使用yo命令后面跟着 去掉generator-后的内容yo node# 在命令行选择填写对应的内容，即可生成对应的项目\n到此我们就生成了一个node项目\n使用Yeoman步骤\n因为使用yeoman可以生成任何项目，所以我们在使用之前需要明确的步骤\n\n明确项目需求\n找到合适的generator\n全局范围安装找到的generator\n通过yo运行对应的generator\n通过命令行交互填写选项\n生成所需要的项目结构\n\n自定义自己的Generator\n&lt;基于Yeoman搭建自己的脚手架&gt;\n创建 Generator 模块 &lt;generator模块本质上就是一个npm模块&gt;\ngenerator模块规定名称格式为 generator-\n1234567mkdir generator-self # 创建generator模块文件cd generator-self # 进入这个文件夹yarn init # 生成package.json文件yarn add yeoman-generator # 安装yeoman的generator模块mkdir generators # 创建生成器目录mkdir generators/app # 创建默认生成器目录touch generators/app/index.js # 创建默认生成器实现的文件\n至此，生成了一个目录结构\n12345├── generators          // 生成器目录│   └── app             // 默认生成器目录│       └── index.js    // 默认生成器实现├── node_modules└── package.json\n\n最主要的文件就是 generators/app/index.js\n\n此文件作为 Generator 的核心入口文件\n需要导出一个继承自 Yeoman Generator 的类型\nYeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法\n我们在这些方法中可以通过调用父类提供的一些工具方法来实现一些功能，例如文件写入\n1234567891011const Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator &#123;    writing () &#123;        // Yeoman 自动在生成文件阶段调用此方法        // 我们这里尝试往项目目录中写入文件        this.fs.write()        this.destinationPath(&#x27;temp.txt&#x27;)        Math.random().toString()    &#125;&#125;\n编写完成之后，需要将此模块链接到全局，将其变为全局模块包\n1yarn link\n此时我们换一个文件夹\n1yo self # self 为刚刚写的生成器的名字\n这就是yeoman生成器最基本的开发过程\n根据模版去创建文件\n一个项目的基础结构是有很多个文件的，如果都手动去创建文件写入内容，那将会变得特别繁琐，所以我们可以将基础结构直接写好，然后通过模版的方式去创建整个项目结构,这样可以大大的提高效率\n12345mkdir generators/app/templates # 创建模版文件夹# 这个文件夹内部的文件就将会作为模版文件去解析# 例：创建一个 foo.txt 模版touch generators/app/templates/foo.txt\n在 foo.txt 中\n12345678内部可以使用 EJS 模版标记输出数据例如: &lt;%= title %&gt;其他的 EJS 语法也支持&lt;% if (success) &#123; %&gt;啦啦啦&lt;% &#125; %&gt;注意：如果内部有属于自己的模版语法，则需要再加一个%&lt;%= BASE_URL %&gt; ===&gt; &lt;%%= BASE_URL %&gt;\n回到 app/index.js 中\n123456789101112... // 省略writing () &#123;    // 通过模版方式写入文件到目标目录    // 模版文件路径    const tmpl = this.templatePath(&#x27;foo.txt&#x27;)    // 输出目标路径    const outPut = this.destinationPath(&#x27;foo.txt&#x27;)    // 模版数据上下文    const context = &#123; title: &#x27;hello&#x27;, success: true &#125;    this.fs.copyTpl(tmpl, outPut, context)&#125;...\n接收用户输入数据\n通过命令行交互的方式，获取用户的输入。提示模块由 Inquirer.js 提供。可以参考官方文档查询API\n123456789101112131415161718192021// 依然是在 app/index.js 文件中prompting() &#123;    // Yeoman 在询问用户环节会自动调用此方法    // 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问    // 参数为一个数组    return this.prompt([        &#123;            type: &#x27;input&#x27;,            name: &#x27;name&#x27;,            message: &#x27;Your project name&#x27;,            default: this.appname // appname 为项目生成目录名称        &#125;    ]).then(answers =&gt; &#123;        // answers =&gt; &#123; name: &#x27;user input value&#x27; &#125;        this.answers = answers    &#125;)&#125;writing () &#123;    ...    const context = this.answers&#125;\n到此，我们就已经可以去实现一个自己的Generator了\n发布 Generator\n当写好了自己的Generator后,一般会将此项目托管到远程的仓库中。\n12345678910111213# 创建排除文件echo node_modules &gt; .gitignoregit initgit add .git commit -m &#x27;init&#x27;git remote add origin https://github.com/user/generator-selfgit push -u origin masteryarn publish # 发布# 国内一般会使用淘宝镜像源取代官方的镜像，所以可能会报错yarn publish --registry=https://registry.yarnpkg.com# 在npm官网就可以查看到这个模块# 随后就可以全局安装使用了\n如果想让自己的 Generator 在 yeoman 官方的仓库列表中也出现的话，可以在项目中添加一个 yeoman-generator 的关键词，这个时候yeoman官方会发现你的项目。\n","plink":"https://rdhuang.gitee.io/2022/01/15/Yeoman入门-实现属于自己的脚手架/"},{"title":"自动化构建","date":"2022-01-05T06:46:55.000Z","date_formatted":{"ll":"Jan 5, 2022","L":"01/05/2022","MM-DD":"01-05"},"updated":"2022-01-05T07:27:58.515Z","content":"自动化构建工作流\n开发阶段自动化转换成生产代码\n这种转换的过程叫做自动化构建工作流\n在开发阶段就可以使用最新的一些特性 Sass等乱七八糟的\n转换哪些不被支持的特性就是构建\n提高\n","plink":"https://rdhuang.gitee.io/2022/01/05/自动化构建/"},{"title":"前端工程化","date":"2022-01-04T06:30:29.000Z","date_formatted":{"ll":"Jan 4, 2022","L":"01/04/2022","MM-DD":"01-04"},"updated":"2022-01-13T02:53:57.662Z","content":"什么是前端工程化\n\n一切以提高效率、降低成本、质量保证为目的的手段都属于【工程化】\n\n一切技术都是为了解决问题在存在的。所以前端工程化的出现也是为了解决前端项目越来越大的问题而出现的。\n前端工程化主要解决的问题\n\n传统语言或语法的弊端\n无法使用模块化/组件化\n重复的机械式工作\n代码风格统一、质量保证\n依赖后端服务接口支持\n整体依赖后端项目\n\n工程化是如何表现的\n以一个项目的开发流程为例\n创建 —&gt; 编码 —&gt; 预览/测试 —&gt; 提交远程仓库 —&gt; 部署上线\n\n在项目创建阶段，我们可以使用脚手架工具进行项目初期的构建\n编码阶段，我们可以制定一个规范，格式化代码，校验代码风格等\n预览/测试阶段，可以使用 webServer 进行热更行，mock去模拟接口数据等\n提交远程仓库，可以使用 GIT Hooks，lint-staged 在提交之前做代码质量，编码风格的检查\n部署上线，CI/CD 自动发布，避免人为操作失误等\n\n工程化并不等于某个工具\n由于 webpack 功能过于强大，会有人认为工程化就是指webpack，其实这是错误的。\n工程化是对项目整体的一种规划和架构，而像webpack等工具只是去实现这种规划和架构的一种手段。\n","plink":"https://rdhuang.gitee.io/2022/01/04/前端工程化/"},{"title":"JavaScript性能优化","date":"2021-12-31T08:09:50.000Z","date_formatted":{"ll":"Dec 31, 2021","L":"12/31/2021","MM-DD":"12-31"},"updated":"2022-01-03T12:12:17.686Z","content":"内存管理\n内存为什么需要管理\n12345function fn () &#123;    list = []    list[10000] = &#x27;lg is a coder&#x27;&#125;fn()\n内存管理介绍\n\n内存：由可读写单元组成，表示一片可操作空间\n管理：人为的去操作一片空间的申请、使用和释放\n内存管理：开发者主动申请空间、使用空间、释放空间\n管理流程：申请 – 使用 – 释放\n\njs中的内存管理\n\n申请内存空间\n\n1let obj = &#123;&#125;\n\n使用内存空间\n\n1obj.name = &#x27;xxx&#x27;\n\n释放内存空间\n\n1obj = null\n垃圾回收机制\n1234567891011121314function objGroup(obj1, obj2) &#123;    obj1.next = obj2    obj2.prev = obj1    return &#123;        o1: obj1,        o2: obj2    &#125;&#125;let obj = objGroup(&#123; name: &#x27;obj1&#x27; &#125;, &#123; name: &#x27;obj2&#x27; &#125;)console.log(obj1)// &#123;//     o1: &#123; name: &#x27;obj1&#x27;, next: &#123; name: &#x27;obj2&#x27;, prev: [Circular] &#125; &#125;,//     o2: &#123; name: &#x27;obj2&#x27;, prev: &#123; name: &#x27;obj1&#x27;, next: [Circular] &#125; &#125;,// &#125;","plink":"https://rdhuang.gitee.io/2021/12/31/JavaScript性能优化/"},{"title":"TypeScript","date":"2021-12-29T12:55:09.000Z","date_formatted":{"ll":"Dec 29, 2021","L":"12/29/2021","MM-DD":"12-29"},"updated":"2021-12-29T13:28:23.289Z","content":"强类型、弱类型\n","plink":"https://rdhuang.gitee.io/2021/12/29/TypeScript/"},{"title":"ECMAScript","date":"2021-12-27T06:00:53.000Z","date_formatted":{"ll":"Dec 27, 2021","L":"12/27/2021","MM-DD":"12-27"},"updated":"2022-01-05T02:10:25.683Z","content":"javascript 其实是 ECMAScript 的拓展语言\nECMAScript 只提供了最基本的语法\n在浏览器中\njs = ECMAScript + 浏览器提供的API，如：BOM、DOM\n在 node 中\njs = ECMAScript + node中提供的API，如：fs、net、etc.\n人们平常说的 ES6 其实是泛指 包含ES2015及后续的所有新特性\n\nvar let const\nlet 块级作用域，没有变量提升阶段，只在当前代码块生效\nconst 在声明的时候就需要定义，一旦定义就不可更改（只适用普通数据类型，对于引用类型只要不改变指针，就可以对内部的数据进行更改）\n数组的解构\n\n12345const arr = [1, 2, 3, 4, 5]const [first, two, ...args] = arrconsole.log(first) // 1console.log(two) // 2console.log(args) // [3, 4, 5]\n\n对象的解构\n\n123const obj = &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, c &#125; = objconsole.log(a, c) // 1 3\n\n模板字符串\n\n123const s1 = &#x27;❤️&#x27;const s2 = `I $&#123; s1 &#125; U`console.log(s2) // I ❤️ U\n\n带标签的模板字符串\n\n12345678const name = &#x27;zhangshan&#x27;const gender = truefunction myTagFunc (strings) &#123;    const sex = gender ? &#x27;man&#x27; : &#x27;woman&#x27;    return strings[0] + name + strings[1] + sex + strings[2]&#125;const result = myTagFunc`hey, $&#123;name&#125; is a $&#123;gender&#125;`console.log(result)\n\n字符串的拓展方法\n\n1234const str = &#x27;Good Good Study, Day Day Up.&#x27;console.log(str.startsWith(&#x27;Good&#x27;)) // trueconsole.log(str.endsWith(&#x27;.&#x27;)) // trueconsole.log(str.includes(&#x27;Study&#x27;)) // true\n\n参数默认值\n\n12345function foo (enable = true) &#123;    console.log(enable)&#125;foo() // truefoo(false) // false\n\n剩余参数\n\n12345function foo (a, b, ...args) &#123;    console.log(args)&#125;foo() // []foo(1, 2, 3, 4, 5, 6, 7) // [3, 4, 5, 6, 7]\n\n展开数组\n\n12const arr = [1, 2, 3]console.log(...arr) // 1 2 3\n\n箭头函数\n\n12345function foo (a, b) &#123;    return a + b&#125;// =======箭头函数改造=======&gt;const foo = (a, b) =&gt; a + b\n\n箭头函数与this\n箭头函数不会改变this的指向\n\n123456789101112131415161718192021function foo () &#123;    const person = &#123;        name: &#x27;TOM&#x27;,        sayHi: function () &#123;            console.log(`hi, my name is $&#123;this.name&#125;`)            // hi, my name is TOM        &#125;        sayHi: () =&gt; &#123;            console.log(`hi, my name is $&#123;this.name&#125;`)            // hi, my name is undefined        &#125;        sayHiAsync: function () &#123;            setTimeout(function() &#123;                console.log(this.name) // undefined            &#125;, 1000)            setTimeout(() =&gt; &#123;                console.log(this.name) // TOM            &#125;, 1000)        &#125;    &#125;&#125;\n\n对象字面量的增强\n\n12345678910111213const bar = &#x27;123&#x27;const obj = &#123;    foo: 345,    // bar: bar,    bar,    // method: function () &#123;    //     console.log(&#x27;xxx&#x27;)    // &#125;    method() &#123;        console.log(&#x27;xxx&#x27;)    &#125;    [Math.random()]: 12345 // 计算属性名&#125;\n\nObject.assign\n\n12345678910111213const obj1 = &#123; a: 1, b: 2, c: 3 &#125;const obj2 = &#123; a: 2, d: 4 &#125;const obj3 = &#123; c: 4, e: 5 &#125;console.log(Object.assign(obj1, obj2, obj3)) // &#123;a: 2, b: 2, c: 4, d: 4, e: 5&#125;function fn (obj) &#123;    const funcObj = Object.assign(&#123;&#125;, obj)    funcObj.name = &#x27;func obj&#x27;    console.log(funcObj)&#125;const obj = &#123; name: &#x27;global obj&#x27; &#125;fn(obj) // &#123; name: func obj &#125;console.log(obj) // &#123; name: global obj &#125;\n\nObject.is\n\n12Object.is(NaN, NaN) // trueNaN === NaN // false\n\nProxy 对比 defineProperty\n\n1234567891011121314151617181920212223const person = &#123;    name: &#x27;zhangshan&#x27;,    age: 18&#125;const personProxy = new Proxy(person, &#123;    get (target, property) &#123;        return property in target ? target[property] : &#x27;default&#x27;    &#125;,    set (target, property, value) &#123;        if (property === &#x27;age&#x27;) &#123;            if (!Number.isInteger(value)) &#123;                throw new TypeError(`$&#123;value&#125; is not an int`)            &#125;        &#125;        target[property] = value    &#125;&#125;)personProxy.age = &#x27;100&#x27; // TypeError: 100 is not an intpersonProxy.age = 100personProxy.gender = trueconsole.log(personProxy.name) // zhangshanconsole.log(personProxy.xxx) // default\n\nObject.defineProperty 只能监听属性的读写\nProxy 能够监视到更多的对象操作\n\n12345678910111213141516new Proxy(person, &#123;    // 方法     触发方式    get() &#123;&#125;, // 读取某个属性    set() &#123;&#125;, // 写入某个属性    has // in 操作符    deleteProperty // delete 操作符    getPrototypeOf // Object.getPrototypeOf()    setPrototypeOf // Object.setPrototypeOf()    isExtensible // Object.isExtensible()    preventExtensions // Object.preventExtensions()    getOwnPropertyDescriptor // Object.getOwnPropertyDescriptor()    defineProperty // Object.defineProperty()    ownKeys // Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()    apply // 调用一个函数    construct // 用 new 调用一个函数&#125;)\n\n可以监视数组\nProxy 是以非侵入的方式监管了对象的读写\n\n\nReflect\n属于一个静态类 不可以使用 new 关键字\n统一提供了一套用于操作对象的 API\n\n12345678910// Reflect.getconst obj = &#123;    foo: &#x27;123&#x27;,    bar: &#x27;456&#x27;&#125;const proxy = new Proxy(obj, &#123;    get(target, property) &#123;        return Reflect.get(target, property)    &#125;&#125;)\n\n\nPromise\n一种更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题\n\n\nclass 类\n\n\n12345678910class Person &#123;    constructor (name) &#123;        this.name = name    &#125;    say () &#123;        console.log(`hi, my name is $&#123;this.name&#125;`)    &#125;&#125;const p = new Person(&#x27;tom&#x27;)p.say()\n\n静态方法 static\n\n12345678910111213class Person &#123;    constructor (name) &#123;        this.name = name    &#125;    say () &#123;        console.log(`hi, my name is $&#123;this.name&#125;`)    &#125;    static create (name) &#123;        return new Person(name)    &#125;&#125;const tom = Person.create(&#x27;tom&#x27;)tom.say()\n\n类的继承\n\n1234567891011121314151617181920class Person &#123;    constructor (name) &#123;        this.name = name    &#125;    say () &#123;        console.log(`hi, my name is $&#123;this.name&#125;`)    &#125;&#125;class Student extends Person &#123;    constructor (name, number) &#123;        super(name)        this.number = number    &#125;    hello () &#123;        super.say()        console.log(`my school number is $&#123;this.number&#125;`)    &#125;&#125;const s = new Student(&#x27;jack&#x27;, &#x27;100&#x27;)s.hello()\n\nSet\nSet内部成员不存在重复\n\n123456789101112const s = new Set()s.add(1).add(2).add(3).add(1)console.log(s) // Set &#123; 1 2 3 &#125;console.log(s.size) // 3s.has(3) // trues.has(5) // falses.delete(1) // trues.clear() // 清空const arr = [1, 2, 3, 4, 1, 2, 3]// const result = Array.from(new Set(arr))const result = [ ...new Set(arr) ]console.log(result) // [1, 2, 3, 4]\n\nMap\n可以用任意类型作为键\n\n123456const m = new Map()const tom = &#123; name: &#x27;tom&#x27; &#125;m.set(tom, 90)console.log(m) // Map &#123; &#123; name: &#x27;tom&#x27; &#125; =&gt; 90 &#125;console.log(m.get(tom)) // 90\n\nSymbol\n新的数据类型\n主要作用就是为对象添加独一无二的属性名\n\n12345678910111213141516Symbol() === Symbol() // falseconst name = Symbol()const person = &#123;    [name]: &#x27;zs&#x27;,    say() &#123;        console.log(this[name])    &#125;&#125;const s1 = Symbol.for(&#x27;foo&#x27;)const s2 = Symbol.for(&#x27;foo&#x27;)console.log(s1 === s2) // trueSymbol.for(true) === Symbol.for(&#x27;true&#x27;) // true 内部会自动转换成字符串Symbol.iteratorSymbol.hasInstance\n\nfor…of 循环\n原理是 Iterable\n\n1234567const arr = [1, 2, 3, 4, 5]for (const item of arr) &#123;    console.log(item)    if (item &gt; 100) &#123;        break // 可以终止循环    &#125;&#125;\n\n可迭代接口 Iterable\n\n\n对象方法不可以用 for…of 循环，但因为 for…of 循环的原理是使用 iterable ，所以我们可以给对象内部手写一个 iterable 让对象也同样可以使用 for…of 去进行遍历\n\n\n实现可迭代接口\n\n1234567891011121314151617181920212223242526272829303132const set = new Set([&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;abc&#x27;])const iterator = set[Symbol.iterator]()console.log(iterator.next()) // &#123; value: &#x27;foo&#x27;, done: false &#125;console.log(iterator.next()) // &#123; value: &#x27;bar&#x27;, done: false &#125;console.log(iterator.next()) // &#123; value: &#x27;abc&#x27;, done: false &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;console.log(iterator.next()) // &#123; value: undefined, done: true &#125;const obj = &#123;    store: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;abc&#x27;],    [Symbol.iterator]: function () &#123;        let index = 0        const self = this        return &#123;            next: function()&#123;                const result = &#123;                    value: self.store[index],                    done: index &gt;= self.store.length                &#125;                index++                return result            &#125;        &#125;    &#125;&#125;for (const item of obj) &#123;    console.log(item)&#125;// foo// bar// abc\n\n迭代器模式\n\n1234567891011121314151617181920212223242526272829303132333435363738const todos = &#123;    life: [&#x27;吃饭&#x27;, &#x27;睡觉&#x27;, &#x27;打豆豆&#x27;],    learn: [&#x27;js&#x27;, &#x27;node&#x27;, &#x27;html&#x27;, &#x27;css&#x27;],    work: [&#x27;跳舞&#x27;, &#x27;唱歌&#x27;],    each: function (callback) &#123;        const all = [].concat(this.life, this.learn, this.work)        for (const item of all) &#123;            callback(item)        &#125;    &#125;,    [Symbol.iterator]: function() &#123;        const all = [...this.life, ...this.learn, ...this.work]        let index = 0        return &#123;            next: function () &#123;                return &#123;                    value: all[index],                    done: index ++ &gt;= all.length                &#125;            &#125;        &#125;    &#125;&#125;// for (const item of todos.life) &#123;//     console.log(item)// &#125;// for (const item of todos.learn) &#123;//     console.log(item)// &#125;// for (const item of todos.work) &#123;//     console.log(item)// &#125;// todos.each(function (item) &#123;//     console.log(item)// &#125;)for (const item of todos) &#123;    console.log(item)&#125;\n\n生成器函数 Generator\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243function * foo () &#123;    console.log(1)    yield 100    console.log(2)    yield 200    console.log(3)    yield 300&#125;const generator = foo()console.log(generator.next()) // 1  &#123; value: 100, done: false &#125;console.log(generator.next()) // 2  &#123; value: 200, done: false &#125;console.log(generator.next()) // 3  &#123; value: 300, done: false &#125;console.log(generator.next()) // &#123; value: undefined, done: true &#125;// 模拟场景function * createIdMaker () &#123;    let id = 1    whild(true) &#123;        yield id ++    &#125;&#125;const idMaker = createIdMaker()console.log(idMaker.next().value) // 1console.log(idMaker.next().value) // 2console.log(idMaker.next().value) // 3console.log(idMaker.next().value) // 4// 使用 Generator 函数实现 iterator 方法const todos = &#123;    life: [&#x27;吃饭&#x27;, &#x27;睡觉&#x27;, &#x27;打豆豆&#x27;],    learn: [&#x27;js&#x27;, &#x27;node&#x27;, &#x27;html&#x27;, &#x27;css&#x27;],    work: [&#x27;跳舞&#x27;, &#x27;唱歌&#x27;],    [Symbol.iterator]: function * () &#123;        const all = [...this.life, ...this.learn, ...this.work]        for (const item of all) &#123;            yield item        &#125;    &#125;&#125;for (const item of todos) &#123;    console.log(item)&#125;\n\n\nES Modules\n\n\nECMAScript2016\n\n\n\nincludes方法\n指数运算符  12Math.pow(2, 10) // 10242 ** 10 // 1024\n\n\n\nES2017\n\n\nObject.values  12345const obj = &#123;    name: &#x27;zs&#x27;,    age: 13&#125;console.log(Object.values(obj)) // [&#x27;zs&#x27;, 13]\n\nObject.entries  1234567891011const obj = &#123;    name: &#x27;zs&#x27;,    age: 13&#125;console.log(Object.entries(obj)) // [ [ name, &#x27;zs&#x27; ], [ age, 13 ] ]for (const [key, value] of Object.entries(obj)) &#123;    console.log(key, value)&#125;// name zs// age 13console.log(new Map(Object.entries(obj))) // Map &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27;, &#x27;age&#x27; =&gt; 13 &#125;\n\nObject.getOwnPropertyDescriptors\nString.protptype.padStart / String.protptype.padEnd\n在函数参数中添加尾逗号\n\n","plink":"https://rdhuang.gitee.io/2021/12/27/ECMAScript/"},{"title":"JS基础夯实","date":"2021-12-22T13:30:34.000Z","date_formatted":{"ll":"Dec 22, 2021","L":"12/22/2021","MM-DD":"12-22"},"updated":"2021-12-27T06:00:22.859Z","content":"基本名词\nJS 的执行平台\n\n在各种浏览器中\n在Node中\n在webView中\n不论什么平台，都需要有一个执行 js 代码的环境，即执行环境\n\n执行环境\n\n我们写的代码，最终都是在设备的物理硬件上运行的，即内存条\njs 代码在执行时会在内存中生成一个栈（先进后出）空间，本质上就是内存条中拿出一个空间\n每当浏览器加载页面时，就会从计算机的内存中申请一片内存空间用来执行 js 代码（执行环境栈【ESC】）\n\n执行上下文\n\n一个js文件会包含多条代码，不同行组合在一个就是一个代码段\njs 代码在执行的时候，会将代码段都放入到执行环境栈当中运行\n为了解决不同代码段之间存在的冲突问题，所以每个代码段都会有一个包裹自己本段代码的环境，即：执行上下文。\n\n进栈执行\n一个动作，将执行上下文放入执行环境栈中执行的过程就是进栈执行\nEC(G) 全局执行上下文\n浏览器在加载界面的时候默认创建\nVO(G) 全局变量对象\n用于存放全局上下文中声明和定义的变量，自动存储了 window 变量，window变量指向 GO 全局对象\nAO 活动对象\n在某一个函数执行上下文中会存在 AO 用于存放当前函数内部的变量数据\nGO 全局对象\n存放了如 setTimeout、JSON、Math … 这些\n声明\nvar let const function 如： var name\n定义\n给某一个变量执行赋值操作 如 name = ‘xxx’\n堆栈\n堆栈中的基本值\nString Number Boolean null undefined\n基本数据类型是直接存放在栈区\n堆栈中的引用类型\n引用类型是存放在堆区（堆内存）\n堆栈中的函数（ 函数 + 对象 ）\n函数的创建\n\n函数在变量提升阶段，同时将声明和定义都做了\n词法作用域（当前函数的作用域和它在哪被调用的没关系，只看它在哪定义的）\n\n函数的调用\n","plink":"https://rdhuang.gitee.io/2021/12/22/JS基础夯实/"},{"title":"模块化","date":"2021-12-21T13:11:58.000Z","date_formatted":{"ll":"Dec 21, 2021","L":"12/21/2021","MM-DD":"12-21"},"updated":"2021-12-27T03:09:24.779Z","content":"模块，模块化开发，规范\n\n模块化开发的目标是把程序拆分成一个个小结构\n在当前的结构中可以编写自己的逻辑代码，他拥有自己的作用域，不会影响到其他结构\n在某个结构中可以向外界暴露自己的变量、函数、对象等给其他结构进行使用\n在其他结构中如果需要使用别的结构的数据，则需要进行导入\n\n那么这些个结构就是模块\n基于这种模式的开发就是模块化开发\n这个导入导出则就是模块化规范\n为什么需要模块化？\n随着前端的发展，业务越来越复杂，特别是从 SPA 应用的出现后，前端所需要编写的代码量越来越大，所以为了方便管理项目，则需要对项目进行拆分，从而也就需要模块化\nCommonJS 和 Node\n\nCJS实现了在非浏览器环境中运行js代码\nNodeJs就是CJS的经典实现\n\nmodule.exports、exports 和 require\nmodule.exports\n123456789// a.jslet obj = &#123;    a: 1,    b: 2&#125;module.exports = obj// b.jsconst obj = require(&#x27;a.js&#x27;)console.log(obj) // &#123; a: 1, b: 2 &#125;\nexports\n1234567891011// a.jslet obj = &#123;    a: 1,    b: 2&#125;exports = obj // 方式1 --- 错误写法exports.obj = obj // 方式2 --- 固定用法// b.jsconst obj = require(&#x27;a.js&#x27;)console.log(obj) // 方式1： &#123;&#125;console.log(obj) // 方式2：&#123; obj: &#123; a: 1, b: 2 &#125; &#125;\n在 Node 的内部实现中, 有下面两行代码\n12module.exports = &#123;&#125;exports = module.exports\n由此可以看出，module.exports 是创建了一个对象，并指向了这个对象，exports = module.exports 操作就让exports同样指向了这个对象，但如果我们做了 exports = obj 这种操作， 相当于是对这个对象进行了重新赋值，指向了一个新对象，那就不对了。\nrequire 规则\n\nrequire(‘fs’) 等\n加载核心模块，直接去查找\nrequire(‘./xxx’) 传入路径形式\n\nrequire(‘./xxx.js’) 带后缀名\n在对应目录查找对应文件\nrequire(‘./xxx’) 传入路径形式，不带后缀的\n先去查找 xxx 文件，没有会进行后缀补全，优先级：.js --&gt; .json --&gt; .node\n如果都没有找到，则会将 xxx 当作目录，查找当前目录下的 index 文件，没有则会继续进行后缀补全，index.js --&gt; index.json --&gt; index.node\n如果上述全部都没有找到，则就会报错了\n\n\nrequire(‘axios’) 非路径，非核心模块\n\n会将其当作第三方模块进行查找\n从当前文件所在目录一级一级向上查找 node_modules，一直找到根目录\n\n\n当多次导入一个文件\n\n123456// a.jsconsole.log(&#x27;a&#x27;)module.exports = &#123; name: &#x27;1234&#x27;, age: 6 &#125;// b.jsrequire(&#x27;./a&#x27;) // arequire(&#x27;./a&#x27;)\n当多次导入一个文件的时候，该文件内的代码只会执行一次，因为会被缓存下来\n5. require() 是同步的加载模式\n12require(&#x27;./a&#x27;) // 在执行到这行时，会停住，直到这个文件内的代码走完以后才会去执行下面的代码console.log(&#x27;aaa&#x27;)\n","plink":"https://rdhuang.gitee.io/2021/12/21/模块化/"},{"title":"手写Promise源码","date":"2021-12-16T12:05:44.000Z","date_formatted":{"ll":"Dec 16, 2021","L":"12/16/2021","MM-DD":"12-16"},"updated":"2021-12-22T12:44:49.867Z","content":"从简单到复杂一步步实现自己的Promise\n\n因为不好拆解，如果想直接看最终版，请跳转到文章末尾最后一个代码块\n\n在手写源码的之前，首先需要知道Promise是什么，都做了哪些操作\n\n\nPromise是一个类,在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行\n\n\nPromise中有三种状态，分别为 成功(fulfilled) 、失败(rejected)、等待(pending)。只能从等待到成功或者失败，且一旦状态确定就不可更改\n\n\nresolve和reject函数是用来更改状态的\n\n\nthen方法做的事情就是判断状态，根据不同的状态调用不同的回调函数，then方法是被定义在原型对象上的\n\n\nthen成功和失败时都会有一个参数，来表示成功或失败后的值或原因\n\n\n同一个promise对象下面的then方法是可以被调用多次的\n\n\nthen方法是可以被链式调用的, 后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值\n\n\nPromise类核心逻辑实现\n123456789101112131415161718192021222324252627282930313233343536373839const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;    constructor (executor) &#123;        executor(this.resolve, this.reject)    &#125;    // promise 状态    status = PENDING    // 成功之后的值    value = undefined    // 失败之后的原因    reason = undefined    resolve = value =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为成功        this.status = FULFILLED        // 保存成功之后的值        this.value = value    &#125;    reject = reason =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为失败        this.status = REJECTED        // 保存失败后的原因        this.reason = reason    &#125;    then (successCallback, failCallback) &#123;        if (this.status === FULFILLED) &#123;            successCallback(this.value)        &#125; else if (this.status === REJECTED) &#123;            failCallback(this.reason)        &#125;    &#125;&#125;module.exports = MyPromise\n\n至此，我们实现了一个最简单版本的 Promise\n\n12345678910// 实现功能const MyPromise = require(&#x27;./MyPromise&#x27;)let promise = new MyPromise(function(resolve, reject)&#123;    console.log(&#x27;promise&#x27;)    resolve(&#x27;success&#x27;)    reject(&#x27;error&#x27;)&#125;)promise.then(value =&gt; console.log(value), reason =&gt; console.log(reason))// promise// success\n加入异步逻辑\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;    constructor (executor) &#123;        executor(this.resolve, this.reject)    &#125;    // promise 状态    status = PENDING    // 成功之后的值    value = undefined    // 失败之后的原因    reason = undefined    // 成功之后的回调    successCallback = undefined    // 失败之后的回调    failCallback = undefined    resolve = value =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为成功        this.status = FULFILLED        // 保存成功之后的值        this.value = value        // 判断成功回调是否存在，存在则调用        this.successCallback &amp;&amp; this.successCallback(this.value)    &#125;    reject = reason =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为失败        this.status = REJECTED        // 保存失败后的原因        this.reason = reason        // 判断失败回调是否存在，存在则调用        this.failCallback &amp;&amp; this.failCallback(this.reason)    &#125;    then (successCallback, failCallback) &#123;        if (this.status === FULFILLED) &#123;            successCallback(this.value)        &#125; else if (this.status === REJECTED) &#123;            failCallback(this.reason)        &#125; else &#123;            // 状态是等待            // 此时需要将callback存储起来            this.successCallback = successCallback            this.failCallback = failCallback        &#125;    &#125;&#125;module.exports = MyPromise\n1234567891011// 实现功能const MyPromise = require(&#x27;./MyPromise&#x27;)let promise = new MyPromise(function(resolve, reject)&#123;    setTimeout(() =&gt; &#123;        console.log(&#x27;promise&#x27;)        resolve(&#x27;success&#x27;)    &#125;, 2000)    // reject(&#x27;error&#x27;)&#125;)promise.then(value =&gt; console.log(value), reason =&gt; console.log(reason))// 2秒后输出 promise    success\n实现 then 方法多次调用添加多个处理函数\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;    constructor (executor) &#123;        executor(this.resolve, this.reject)    &#125;    // promise 状态    status = PENDING    // 成功之后的值    value = undefined    // 失败之后的原因    reason = undefined    // 成功之后的回调    successCallback = []    // 失败之后的回调    failCallback = []    resolve = value =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为成功        this.status = FULFILLED        // 保存成功之后的值        this.value = value        // 判断成功回调是否存在，存在则调用        // this.successCallback &amp;&amp; this.successCallback(this.value)        while (this.successCallback.length) this.successCallback.shift()(this.value)    &#125;    reject = reason =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为失败        this.status = REJECTED        // 保存失败后的原因        this.reason = reason        // 判断失败回调是否存在，存在则调用        // this.failCallback &amp;&amp; this.failCallback(this.reason)        while (this.failCallback.length) this.failCallback.shift()(this.reason)    &#125;    then (successCallback, failCallback) &#123;        if (this.status === FULFILLED) &#123;            successCallback(this.value)        &#125; else if (this.status === REJECTED) &#123;            failCallback(this.reason)        &#125; else &#123;            // 状态是等待            // 此时需要将callback存储起来            this.successCallback.push(successCallback)            this.failCallback.push(failCallback)        &#125;    &#125;&#125;module.exports = MyPromise\n12345678910111213// 实现功能const MyPromise = require(&#x27;./MyPromise&#x27;)let promise = new MyPromise(function(resolve, reject)&#123;    setTimeout(() =&gt; &#123;        console.log(&#x27;promise&#x27;)        resolve(&#x27;success&#x27;)    &#125;, 2000)    // reject(&#x27;error&#x27;)&#125;)promise.then(value =&gt; console.log(value), reason =&gt; console.log(reason))promise.then(value =&gt; console.log(value), reason =&gt; console.log(reason))promise.then(value =&gt; console.log(value), reason =&gt; console.log(reason))// 2秒后输出 promise success success success\n实现then方法的链式调用\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;    constructor (executor) &#123;        executor(this.resolve, this.reject)    &#125;    // promise 状态    status = PENDING    // 成功之后的值    value = undefined    // 失败之后的原因    reason = undefined    // 成功之后的回调    successCallback = []    // 失败之后的回调    failCallback = []    resolve = value =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为成功        this.status = FULFILLED        // 保存成功之后的值        this.value = value        // 判断成功回调是否存在，存在则调用        // this.successCallback &amp;&amp; this.successCallback(this.value)        while (this.successCallback.length) this.successCallback.shift()(this.value)    &#125;    reject = reason =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为失败        this.status = REJECTED        // 保存失败后的原因        this.reason = reason        // 判断失败回调是否存在，存在则调用        // this.failCallback &amp;&amp; this.failCallback(this.reason)        while (this.failCallback.length) this.failCallback.shift()(this.reason)    &#125;    then (successCallback, failCallback) &#123;        // then 方法返回的是一个 promise        return new MyPromise((resolve, reject) =&gt; &#123;            // 判断状态            if (this.status === FULFILLED) &#123;                let v = successCallback(this.value)                // 判断 v 的值是普通值还是promise对象                // 如果是普通值，直接调用 resolve                // 如果是 promise 对象，查看promise对象返回的结果                // 再根据promise对象返回的结果，决定调用resolve还是reject                resolvePromise(v, resolve, reject)            &#125; else if (this.status === REJECTED) &#123;                failCallback(this.reason)            &#125; else &#123;                // 状态是等待                // 此时需要将callback存储起来                this.successCallback.push(successCallback)                this.failCallback.push(failCallback)            &#125;        &#125;)    &#125;&#125;function resolvePromise (v, resolve, reject) &#123;    if (v instanceof MyPromise) &#123;        // v.then(value =&gt; resolve(value), reason =&gt; reject(reason))        v.then(resolve, reject)    &#125; else &#123;        resolve(v)    &#125;&#125;module.exports = MyPromise\n123456789101112131415161718// 实现功能const MyPromise = require(&#x27;./MyPromise&#x27;)let promise = new MyPromise(function(resolve, reject)&#123;    resolve(&#x27;success&#x27;)&#125;)function other() &#123;    return new MyPromise(resolve =&gt; &#123;        resolve(&#x27;other&#x27;)    &#125;)&#125;promise.then(value =&gt; &#123;    console.log(value)    return other()&#125;).then(value =&gt; &#123;    console.log(value)&#125;)// success// other\n*终版 (针对一些异常情况并没有做处理)\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;    constructor(executor) &#123;        // 如果在执行执行器的时候报错了，需要捕获错误情况        try &#123;            // 传入立即执行的执行器            executor(this.resolve, this.reject)        &#125; catch (e) &#123;            this.reject(e)        &#125;    &#125;    // promise 状态    status = PENDING    // 成功之后的值    value = undefined    // 失败之后的原因    reason = undefined    // 成功之后的回调    successCallback = []    // 失败之后的回调    failCallback = []    resolve = value =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为成功        this.status = FULFILLED        // 保存成功之后的值        this.value = value        // 判断成功回调是否存在，存在则调用        // this.successCallback &amp;&amp; this.successCallback(this.value)        // 当使用 then 方法多次调用时，添加多个处理函数        while (this.successCallback.length) this.successCallback.shift()()    &#125;    reject = reason =&gt; &#123;        // 因为状态一旦确定就不可以更改，所以需要有一层判断        if (this.status !== PENDING) return        // 状态更改为失败        this.status = REJECTED        // 保存失败后的原因        this.reason = reason        // 判断失败回调是否存在，存在则调用        // this.failCallback &amp;&amp; this.failCallback(this.reason)        // 当使用 then 方法多次调用时，添加多个处理函数        while (this.failCallback.length) this.failCallback.shift()()    &#125;    then(successCallback, failCallback) &#123;        // 实现 .then() 参数可选        successCallback = successCallback ? successCallback : value =&gt; value        failCallback = failCallback ? failCallback : reason =&gt; &#123; throw reason &#125;        // then 方法返回的是一个 promise，实现链式调用        let promise2 = new MyPromise((resolve, reject) =&gt; &#123;            // 判断状态            // 判断当状态为成功时，调用成功回调            if (this.status === FULFILLED) &#123;                setTimeout(() =&gt; &#123;                    // 如果 then 方法在执行过程中报错，需要捕获到这个错误，并提示出来                    try &#123;                        let v = successCallback(this.value)                        // 判断 v 的值是普通值还是promise对象                        // 如果是普通值，直接调用 resolve                        // 如果是 promise 对象，查看promise对象返回的结果                        // 再根据promise对象返回的结果，决定调用resolve还是reject                        resolvePromise(promise2, v, resolve, reject) // 此时primise2还获取不到，所以需要将此编程异步代码                    &#125; catch (e) &#123;                        reject(e)                    &#125;                &#125;, 0)            &#125; else if (this.status === REJECTED) &#123;                setTimeout(() =&gt; &#123;                    // 如果 then 方法在执行过程中报错，需要捕获到这个错误，并提示出来                    try &#123;                        // 当状态为失败时，调用失败回调                        let v = failCallback(this.reason)                        // 判断 v 的值是普通值还是promise对象                        // 如果是普通值，直接调用 resolve                        // 如果是 promise 对象，查看promise对象返回的结果                        // 再根据promise对象返回的结果，决定调用resolve还是reject                        resolvePromise(promise2, v, resolve, reject) // 此时primise2还获取不到，所以需要将此编程异步代码                    &#125; catch (e) &#123;                        reject(e)                    &#125;                &#125;, 0)            &#125; else &#123;                // 状态是等待，意味着是异步操作的时候                // 此时需要将callback存储起来                this.successCallback.push(() =&gt; &#123;                    setTimeout(() =&gt; &#123;                        // 如果 then 方法在执行过程中报错，需要捕获到这个错误，并提示出来                        try &#123;                            let v = successCallback(this.value)                            // 判断 v 的值是普通值还是promise对象                            // 如果是普通值，直接调用 resolve                            // 如果是 promise 对象，查看promise对象返回的结果                            // 再根据promise对象返回的结果，决定调用resolve还是reject                            resolvePromise(promise2, v, resolve, reject) // 此时primise2还获取不到，所以需要将此编程异步代码                        &#125; catch (e) &#123;                            reject(e)                        &#125;                    &#125;, 0)                &#125;)                this.failCallback.push(() =&gt; &#123;                    setTimeout(() =&gt; &#123;                        // 如果 then 方法在执行过程中报错，需要捕获到这个错误，并提示出来                        try &#123;                            // 当状态为失败时，调用失败回调                            let v = failCallback(this.reason)                            // 判断 v 的值是普通值还是promise对象                            // 如果是普通值，直接调用 resolve                            // 如果是 promise 对象，查看promise对象返回的结果                            // 再根据promise对象返回的结果，决定调用resolve还是reject                            resolvePromise(promise2, v, resolve, reject) // 此时primise2还获取不到，所以需要将此编程异步代码                        &#125; catch (e) &#123;                            reject(e)                        &#125;                    &#125;, 0)                &#125;)            &#125;        &#125;)        return promise2    &#125;    // 实现 catch 方法    catch (failCallback) &#123;        // catch 方式其实就是 then 方法，只是第一个参数传入 undefined 就ok了        return this.then(undefined, failCallback)    &#125;    // 谁先 finally 方法    finally(callback) &#123;        // 如果成功失败都会执行，所以不依赖状态        return this.then(value =&gt; &#123;            return MyPromise.resolve(callback()).then(() =&gt; value)            // callback()            // return value        &#125;, reason =&gt; &#123;            return MyPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)            // callback()            // throw reason        &#125;)    &#125;    // 实现 all 方法，接收一个数组参数    static all(array) &#123; // 基础版，未考虑异常情况，没有对传入数据做校验，默认传值是正确的        let result = [] // 返回值        let index = 0 // 索引        return new MyPromise((resolve, reject) =&gt; &#123;            // 添加数据h桉树，key 即索引            function addData(key, value) &#123;                result[key] = value // 将结果传入返回值中                index++ // 每次添加都自增 1                // 因为可能内部存在异步代码，for循环是立即执行完成，所以，需要在判断全部相等之后，再去返回 resolve                if (index === array.length) &#123; // 判断，只有当所有的全部添加完成之后，返回 resolve                    resolve(result)                &#125;            &#125;            // 循环遍历传入的数组参数            for (let i = 0; i &lt; array.length; i++) &#123;                let current = array[i] // 拿到当前的值                if (current instanceof MyPromise) &#123;                    // promise 对象                    current.then(value =&gt; &#123; addData(i, value) &#125;, error =&gt; reject(error))                &#125; else &#123;                    // 普通值                    addData(i, array[i])                &#125;            &#125;        &#125;)    &#125;    // 实现静态 resolve 方法， 传入参数    static resolve(value) &#123;        // 判断参数是否为 promise，如果是，直接返回        if (value instanceof MyPromise) return value        // 如果是一个普通值，则返回 promise，在 resolve中传入 value        return new MyPromise(resolve =&gt; resolve(value))    &#125;&#125;function resolvePromise(promise2, v, resolve, reject) &#123;    // 如果返回的primise同当前的promise是同一个promise，则报错并return 阻止程序继续向下执行    if (promise2 === v) &#123;        return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;))    &#125;    if (v instanceof MyPromise) &#123;        // v.then(value =&gt; resolve(value), reason =&gt; reject(reason))        v.then(resolve, reject)    &#125; else &#123;        resolve(v)    &#125;&#125;module.exports = MyPromise\n","plink":"https://rdhuang.gitee.io/2021/12/16/手写Promise源码/"},{"title":"JavaScript异步编程","date":"2021-12-02T12:12:38.000Z","date_formatted":{"ll":"Dec 2, 2021","L":"12/02/2021","MM-DD":"12-02"},"updated":"2021-12-16T12:03:35.849Z","content":"JS异步编程的介绍\n首先说说为什么会有JS异步编程\n众所周知，JS是单线程模式工作的，因为JS是运行在浏览器端的脚本语言，目的是为了实现页面的交互，那么因为页面交互主要是DOM操作，从而决定了它必须使用单线程模式工作，否则就会出现特别复杂的线程同步问题。\n这种模式优点是更安全、更简单，缺点就是如果在代码执行中遇到一个特别耗时的操作，那么后面的代码就必须等待这个操作结束以后才可以执行。\n所以，为了解决像这样的情况，JS将任务的执行模式分成了两种，分别是同步模式(Synchronous)和异步模式(Asynchronous)\n同步模式和异步模式\n\n同步模式\n至上而下依次执行，代码可读性高\n\n123456789101112131415console.log(&#x27;global begin&#x27;)function bar () &#123;    console.log(&#x27;bar&#x27;)&#125;function foo() &#123;    console.log(&#x27;foo&#x27;)    bar()&#125;foo()console.log(&#x27;global end&#x27;)// global begin// foo// bar// global end\n\n异步模式\n通过事件循环和消息队列实现的\n\n123456789101112131415161718console.log(&#x27;g1 begin&#x27;)setTimeout(function timer1() &#123;    console.log(&#x27;timer1&#x27;)&#125;, 1800) // 这里如果把时间改为 &gt;= 2000 则结果 timer1 会在 timer3 之后打印setTimeout(function timer2() &#123;    console.log(&#x27;timer2&#x27;)    setTimeout(function timer3() &#123;        console.log(&#x27;timer3&#x27;)    &#125;, 1000)&#125;, 1000)console.log(&#x27;g1 end&#x27;)// g1 begin// g1 end// timer2// timer1// timer3\nPromise\n状态只有三种 PENDING FULFILLED REJECTED\n单向转换，且状态不可再更改\npending —&gt; fulfilled\npending —&gt; rejected\n1234new Promise((resolve, reject) =&gt; &#123;    resolve(&#x27;success&#x27;)    // reject(&#x27;error&#x27;)&#125;)\n\n链式调用\n\n1234567891011let promise = new Promise((resolve, reject) =&gt; &#123;    resolve(&#x27;success&#x27;)&#125;)promise    .then(v =&gt; &#123;        console.log(v) // success        return &#x27;2&#x27;    &#125;)    .then(v =&gt; console.log(v)) // 2    .then()    .then()\n\n静态方法\n\n1234// 直接成功Promise.resolve()// 直接失败Promise.reject()\n\nPromise 并行\n\n123// all() 和 race() 的区别Promise.all() // 是等待所有的异步任务都执行结束以后才会结束Promise.race() // 当有一个任务结束的时候就结束\n宏任务、微任务\n目前大部分异步调用都是作为宏任务执行的, 如：setTimeout…\n作为微任务处理的有：\nPromise 和 MutationObserver 和 nodeJs中的 process.nextTick\nGenerator 生成器函数\n123456789101112131415161718192021// 带有 * 的函数为生成器函数function * foo() &#123;    console.log(&#x27;start&#x27;)    // yield 会暂停执行，但不会结束，当下次再调用 next() 的时候会继续往下执行    try &#123;        let res = yield &#x27;foo&#x27;         console.log(res)    &#125; catch (e) &#123;        console.log(e)    &#125;&#125;// 生成器函数调用不会立即执行const generator = foo()// 当手动调用 next() 方法时才会执行// 如果在next()中传入参数，则会作为 yield 语句的返回值let result = generator.next(&#x27;bar&#x27;)// result返回值 为一个对象，存在两个参数： value 和 done// value 为 生成器函数 yield 的返回值// done 为判断当前生成器是否全部执行完成 值为： true or false// 当调用 throw 方法抛出异常时，可以在函数中通过 try catch 接收generator.throw(new Error(&#x27;Generator Error&#x27;))\nAsync / Await 语法糖\n语言层面的异步编程标准\n同Generator功能一样，只是把 * 换成 async, yield换成await\n1234async function () &#123;    let res = await xxx    console.log(res)&#125;\n全局捕获异常*\n\nunhandledrejection\n\n1234567891011121314// 在浏览器上window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt; &#123;    const &#123; reason, promise &#125; = event    console.log(reason, promise)    // reason =&gt; Promise 失败原因，一般是一个错误对象    // promise =&gt; 出现异常的 Promise 对象    event.preventDefault()&#125;, false)// 在 node 上process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; &#123;    console.log(reason, promise)    // reason =&gt; Promise 失败原因，一般是一个错误对象    // promise =&gt; 出现异常的 Promise 对象&#125;)\n","plink":"https://rdhuang.gitee.io/2021/12/02/JavaScript异步编程/"},{"title":"函数式编程","date":"2021-11-30T15:45:00.000Z","date_formatted":{"ll":"Nov 30, 2021","L":"11/30/2021","MM-DD":"11-30"},"updated":"2021-12-14T13:16:58.752Z","content":"\n函数式编程概念\n函数式编程（Functional Programming, FP）是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。\n它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 就是对运算过程进行抽象，函数式编程中函数指的不是程序中的函数（方法），而是数学中的函数即映射关系。\n123456789101112// 非函数式编程let num1 = 1let num2 = 2let sum = num1 + num2console.log(sum)// 函数式function add (n1, n2) &#123;    return n1 + n2&#125;let sum = add(1, 2)console.log(sum)\n函数式编程的特性\n\n\n函数是“第一等公民（first class）”\n&quot;第一等公民&quot;指的是函数与其他数据类型一样，处于平等地位,可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n\n函数可以赋值给其他变量\n\n  1234567891011121314const fn = () =&gt; &#123;    console.log(&#x27;我可以存储在变量中&#x27;)&#125;fn()// 示例const obj = &#123;    index (posts) &#123; return Views.index(posts) &#125;&#125;// 优化const obj = &#123;    index: Views.index&#125;\n\n\n高阶函数(Higher-order function)\n什么是高阶函数\n\n可以把函数作为参数传递给另一个函数\n\n  12345678// forEachconst forEach = (array, fn) =&gt; &#123;    for (let i = 0; i &lt; array.length; i ++) &#123;        fn(array[i])    &#125;&#125;let arr = [1, 2, 3, 4, 5]forEach(arr, i =&gt; &#123; console.log(i) &#125;)\n\n可以把函数作为另一个函数的返回结果\n\n  1234567891011121314const once = fn =&gt; &#123;    let flag = false    // 注意：这里返回的函数如果写成箭头函数的话，会找不到 this    return function () &#123;        if (!flag) &#123;            flag = true            return fn.apply(this, arguments)        &#125;    &#125;&#125;const pay = once(money =&gt; &#123; console.log(`支付了$&#123;money&#125;元`) &#125;)pay(5)pay(5)pay(5)\n使用高阶函数的意义\n\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n高阶函数是用来抽象通用的问题\n\n\n\n闭包(Closure)\n函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包\n\n\n可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员\n\n\n本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n\n  1234567891011121314// 案例function makePower (power) &#123;    return function (number) &#123;        return Math.pow(number, power)    &#125;&#125;// 优化写法const makePower = power =&gt; num =&gt; Math.pow(num, power)let power2 = makePower(2) // 求平方let power3 = makePower(3) // 求立方console.log(power2(2))console.log(power2(3))console.log(power3(2))\n\n\n纯函数\n\n相同的输入永远会得到相同的输出, 而且没有任何可观察的副作用\n\n  123456789let arr = [1, 2, 3, 4, 5]// 纯函数console.log(arr.slice(0, 3)) // [1, 2, 3]console.log(arr.slice(0, 3)) // [1, 2, 3]// 不纯函数console.log(arr.splice(0, 3)) // [1, 2, 3]console.log(arr.splice(0, 3)) // [4, 5]console.log(arr.splice(0, 3)) // []\n\n\n惰性计算\n在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。\n\n\n不修改状态\n函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。\n\n\n没有&quot;副作用&quot;\n所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。\n\n\n函数式编程的优点\n\n代码简洁，开发快速\n接近自然语言，易于理解\n更方便代码管理\n易于“并发编程”\n代码的热升级\n\n函数式编程基础\nlodash\nlodash（中文官网、英文官网）是一个一致性、模块化、高性能的 JavaScript 实用工具库\n\n安装\n\n1npm install lodash\n\n引入\n\n1const _ = require(&#x27;lodash&#x27;)\n\n使用\n\n123456789const array = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;]console.log(_.first(array)) // red console.log(_.last(array)) // pinkconsole.log(_.toUpper(_.first(array))) // REDconsole.log(_.reverse(array) // [&#x27;pink&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;red&#x27;]_.each(array, (v, i) =&gt; &#123;    console.log(v, i) // red 0  green 1  yellow 2  pink 3&#125;)\n纯函数\n\n可缓存\n\n因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\n\n  1234567891011121314151617181920// 记忆函数 const _ = require(&#x27;lodash&#x27;)function getArea (r) &#123;    console.log(r, &#x27;我只会执行一次，因为我被缓存起来了&#x27;)    return Math.PI * r * r&#125;let getAreaWithMemory = _.memoize(getArea)console.log(getAreaWithMemory(4))console.log(getAreaWithMemory(4))console.log(getAreaWithMemory(4))// 模拟实现function myMemoize(fn) &#123;    let cache = &#123;&#125;    return function () &#123;        let key = JSON.stringify(arguments)        cache[key] = cache[key] || fn.apply(fn, arguments)        return cache[key]    &#125;&#125;\n\n可测试\n\n纯函数可以让测试更方便\n\n\n并行处理\n\n在多线程环境下，并行操作共享的内存数据很可能会出现意外情况\n纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(Web Worker)\n\n\n\n函数柯里化\n\n在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n1234567// 简单的举例const add = (a, b) =&gt; a + b// Currying 后const curryingAdd = a =&gt; b =&gt; a + badd(1, 2) // 3curryingAdd(1)(2) // 3\n由此可以看出，柯里化一个函数，就是把原可以接收多个参数的函数变换成只接收单一参数，并用返回的函数接收余下的参数且返回结果的技术。\n1234567891011121314151617181920// 例：判断年龄基准值function checkAge (min, age) &#123;    return age &gt;= min&#125;// Currying 后function checkAge (min) &#123;    return function (age) &#123;        return age &gt;= min    &#125;&#125;// ES6 写法let checkAge = min =&gt; (age =&gt; age &gt;= min)let checkAge18 = checkAge(18)let checkAge20 = checkAge(20)checkAge18(16) // falsecheckAge18(20) // truecheckAge20(18) // falsecheckAge20(22) // true\n12345678910111213141516171819// 模拟实现 lodash 中的 curry 方法 （传入一个函数，把该函数转换为柯里化函数）const curry = fn =&gt; &#123;    return function curriedFn(...args) &#123;        if (args.length &lt; fn.length) &#123;            return function () &#123;                return curriedFn(...args.concat(Array.from(arguments)))            &#125;        &#125;        return fn(...args)    &#125;&#125;const getSum = (a, b, c) =&gt; (a + b + c)const curried = curry(getSum)curried(1, 2, 3) // 6curried(1, 2)(3) // 6curried(1)(2, 3) // 6curried(1)(2)(3) // 6\n总结\n\n\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n\n\n这是一种对函数参数的‘缓存’\n\n\n让函数变得更灵活，让函数的粒度更小\n\n\n可以把多元函数转换成一元函数，可以组合使用，产生强大的功能\n\n\n12345678910111213141516171819面试题：// 实现一个add方法，使计算结果能够满足如下预期：// add(1)(2)(3) = 6;// add(1, 2, 3)(4) = 10;// add(1)(2)(3)(4)(5) = 15;const add = (...rest) =&gt; &#123;    const fn = (...args) =&gt; &#123;        rest.push(...args)        return fn    &#125;    fn.toString = () =&gt; rest.reduce((total, num) =&gt; total + num, 0)    return fn&#125;console.log(+add(1)(2)(3)) // 6console.log(+add(1, 2, 3)(4)) // 10console.log(+add(1)(2)(3)(4)(5)) // 15\n组合函数\n\n\n函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间的过程函数合并成一个函数\n\n\n函数组合默认是从右到左执行\n\n\n123456789101112131415161718192021// 实现一个组合函数function compose (...args) &#123;    return function (value) &#123;        return args.reverse().reduce(function (acc, fn) &#123;            return fn(acc)        &#125;, value)    &#125;&#125;// ES6改造一下const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)// 测试const fn1 = arr =&gt; arr.reverse()const fn2 = arr =&gt; arr[0]const fn3 = str =&gt; str.toUpperCase()const f = compose(fn3, fn2, fn1)// const f = compose(compose(fn3, fn2), fn1)// const f = compose(fn3, compose(fn2, fn1))console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])) // THREE\n\n函数组合要满足结合律(associativity)\n\n我们既可以把 a 和 b 组合，还可以把 b 和 c 组合，结果都是一样的\n1234// 结合律let f = compose(a, b, c)compose(compose(a, b), c) == compose(a, compose(b, c))// true\n\n组合函数的调试\n\n123456789const _ = require(&#x27;lodash&#x27;)// 需要写一个辅助函数做调试const trace = _.curry((tag, v) =&gt; &#123;    console.log(tag, v)    return v&#125;)// 将此辅助函数插入到组合函数中即可compose(a, trace(&#x27;我在b之后&#x27;)， b, trace(&#x27;我在c之后&#x27;), c)\nPoint Free模式\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数\n\n不需要指明处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数\n\n案例演示\n123456789101112// Hello World =&gt; hello_world// 非 Point Free 模式function f (str) &#123;    return str.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;)&#125;// Point Freeconst fp = require(&#x27;lodash/fp&#x27;)const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;_&#x27;), fp.toLower)console.log(f(&#x27;Hello World&#x27;)) // hello_world\n函子(Functor)\n什么是Functor?\n\n容器：包含值和值的变形关系（这个变形关系就是函数）\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以i运行一个函数对值进行处理（变形关系）\n\n总结\n\n函数式编程的运算不直接操作值，而是由函子完成\n函子就是一个实现了map契约的对象\n我们可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最终map方法返回一个包含新值的盒子（函子）\n\nFunctor\n12345678910111213141516171819202122232425262728class Container &#123;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return new Container(fn(this._value))    &#125;&#125;new Container(5)    .map(v =&gt; v + 1) // Container &#123; _value: 6 &#125;    .map(v =&gt; v * v) // Container &#123; _value: 36 &#125;// ============改============造============&gt;class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return Container.of(fn(this._value))    &#125;&#125;Container.of(5)    .map(v =&gt; v + 1) // Container &#123; _value: 6 &#125;    .map(v =&gt; v * v) // Container &#123; _value: 36 &#125;\nMayBe\n处理空值情况\n1234567891011121314151617class MayBe &#123;    static of(value) &#123;        return new MayBe(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return this.isNothing() ? MayBe.of(this._value) : MayBe.of(fn(this._value))    &#125;    isNothing () &#123;        return this._value === null || this._value === undefined    &#125;&#125;MayBe.of(null)    .map(v =&gt; v * v)    // MayBe &#123; _value: null &#125;\nEither\n\nEither 两者中的任何一个，类似与 if…else… 的处理\n异常会让函数变得不纯，Either 函子可以用来做异常处理\n\n12345678910111213141516171819202122232425262728293031class Left &#123;    static of (value) &#123;        return new Left(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return this    &#125;&#125;class Right &#123;    static of (value) &#123;        return new Right(value)    &#125;    constructor (value) &#123;        this._value = value    &#125;    map (fn) &#123;        return Right.of(fn(this._value))    &#125;&#125;function parseJSON (str) &#123;    try &#123;        return Right.of(JSON.parse(str))    &#125; catch (e) &#123;        return Left.of(&#123; error: e.message &#125;)    &#125;&#125;parseJSON(&#x27;&#123; name: xxx &#125;&#x27;) // Left &#123; _value: &#123;error: &#x27;Unexpected token n in JSON at position 2&#x27;&#125; &#125;\nIO\n\nIO 函子中 _value 是一个函数，这里是把函数作为值来处理\nIO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作（惰性执行），让当前的操作变为纯的操作\n把不纯的操作交给调用者来处理\n\n123456789101112131415161718const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;    static of (value) &#123;        return new IO(function() &#123;            return value        &#125;)    &#125;    constructor (fn) &#123;        this._value = fn    &#125;    map (fn) &#123;        return new IO(fp.flowRight(fn, this._value))    &#125;&#125;let r = IO.of(process).map(p =&gt; p.execPath) // IO &#123; _value: [Function] &#125;r._value() // C:\\xxx\\xxx\\xxx\\xxx\nTask\n异步执行\n\n异步任务的实现过于复杂，我们使用folktale中的Task来演示\nfolktale一个标准的函数式编程库\n\n和 lodash、ramda不同的是，没有提供很多功能函数\n只提供了一些函数式处理的操作，例如：compose、curry等，一些函子 Task、Either、MayBe等\n\n\n\n1234567891011const &#123; compose, curry &#125; = require(&#x27;folktale/core/lambda&#x27;)const &#123; toUpper, first &#125; = require(&#x27;lodash/fp&#x27;)let f = curry(2, (x, y) =&gt; &#123;    return x + y&#125;)f(1, 2) // 3f(1)(2) // 3let fn = compose(toUpper, first)fn([&#x27;one&#x27;, &#x27;two&#x27;]) // ONE\nTask处理异步任务\n123456789101112131415161718const fs = require(&#x27;fs&#x27;)const &#123; task &#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile (filename) &#123;    return task(resolver =&gt; &#123;        fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;            if (err) resolver.reject(err)            resolver.resolve(data)        &#125;)    &#125;)&#125;readFile(&#x27;xxx.xx&#x27;) // 查找某一文件    .map(fn) // 可以对文件进行某些处理    .map(fn) // 可以对文件进行某些处理(可以进行多次处理)    .run() // 执行    .listen(&#123; // 监听        onRejected: err =&gt; console.log(err), // 失败        onResolved: value =&gt; console.log(value) // 成功    &#125;)\nPointed函子\n\nPointed 函子是实现 of 静态方法的函子\nof 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值）\n\n1234567class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    ...&#125;Container.of(6).map(v =&gt; v * v)\nMonad\n\nMonad 函子是可以变扁的 Pointed 函子， IO(IO(x)),解决嵌套的问题\n一个函子如果具有 join 和 of 两个方法，并遵守一些定律就是一个 Monad\n\n1234567891011121314151617181920212223242526272829303132333435const fs = require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;    static of (value) &#123;        return new IO(function() &#123;            return value        &#125;)    &#125;    constructor (fn) &#123;        this._value = fn    &#125;    map (fn) &#123;        return new IO(fp.flowRight(fn, this._value))    &#125;    join () &#123;        return this._value()    &#125;    flatMap (fn) &#123;        return this.map(fn).join()    &#125;&#125;let readFile = function (filename) &#123;    return new IO(function () &#123;        return fs.readFileSync(filename, &#x27;utf-8&#x27;)    &#125;)&#125;let print = function (x) &#123;    return new IO(function() &#123;        console.log(x)        return x    &#125;)&#125;readFile(&#x27;xxxx.xx&#x27;).faltMap(print).join()\n","plink":"https://rdhuang.gitee.io/2021/11/30/函数式编程/"}]