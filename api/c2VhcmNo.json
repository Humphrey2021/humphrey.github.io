[{"title":"函数式编程","date":"2021-11-30T15:45:00.000Z","date_formatted":{"ll":"Nov 30, 2021","L":"11/30/2021","MM-DD":"11-30"},"updated":"2021-12-02T12:01:25.849Z","content":"\n函数式编程概念\n函数式编程（Functional Programming, FP）是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。\n它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 就是对运算过程进行抽象，函数式编程中函数指的不是程序中的函数（方法），而是数学中的函数即映射关系。\n123456789101112// 非函数式编程let num1 = 1let num2 = 2let sum = num1 + num2console.log(sum)// 函数式function add (n1, n2) &#123;    return n1 + n2&#125;let sum = add(1, 2)console.log(sum)\n函数式编程的特性\n\n\n函数是“第一等公民（first class）”\n&quot;第一等公民&quot;指的是函数与其他数据类型一样，处于平等地位,可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。\n\n函数可以赋值给其他变量\n\n  1234567891011121314const fn = () =&gt; &#123;    console.log(&#x27;我可以存储在变量中&#x27;)&#125;fn()// 示例const obj = &#123;    index (posts) &#123; return Views.index(posts) &#125;&#125;// 优化const obj = &#123;    index: Views.index&#125;\n\n\n高阶函数(Higher-order function)\n\n可以把函数作为参数传递给另一个函数\n\n  12345678// forEachconst forEach = (array, fn) =&gt; &#123;    for (let i = 0; i &lt; array.length; i ++) &#123;        fn(array[i])    &#125;&#125;let arr = [1, 2, 3, 4, 5]forEach(arr, i =&gt; &#123; console.log(i) &#125;)\n\n可以把函数作为另一个函数的返回结果\n\n  1234567891011121314const once = fn =&gt; &#123;    let flag = false    // 注意：这里返回的函数如果写成箭头函数的话，会找不到 this    return function () &#123;        if (!flag) &#123;            flag = true            return fn.apply(this, arguments)        &#125;    &#125;&#125;const pay = once(money =&gt; &#123; console.log(`支付了$&#123;money&#125;元`) &#125;)pay(5)pay(5)pay(5)\n\n\n闭包(Closure)\n函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包\n\n\n可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员\n\n\n本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n\n\n  1234567891011121314// 案例function makePower (power) &#123;    return function (number) &#123;        return Math.pow(number, power)    &#125;&#125;// 优化写法const makePower = power =&gt; num =&gt; Math.pow(num, power)let power2 = makePower(2) // 求平方let power3 = makePower(3) // 求立方console.log(power2(2))console.log(power2(3))console.log(power3(2))\n\n\n纯函数\n\n相同的输入永远会得到相同的输出, 而且没有任何可观察的副作用\n\n  123456789let arr = [1, 2, 3, 4, 5]// 纯函数console.log(arr.slice(0, 3)) // [1, 2, 3]console.log(arr.slice(0, 3)) // [1, 2, 3]// 不纯函数console.log(arr.splice(0, 3)) // [1, 2, 3]console.log(arr.splice(0, 3)) // [4, 5]console.log(arr.splice(0, 3)) // []\n\n\n惰性计算\n在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。\n\n\n递归\nFP 还有一个特点是用递归做为控制流程的机制。\n\n\n只用&quot;表达式&quot;，不用&quot;语句&quot;\n\n\n没有&quot;副作用&quot;\n所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。\n函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。\n\n\n不修改状态\n函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。\n\n\n引用透明性\n函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。\n\n\n副作用\n副作用是修改系统状态的语言结构。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。\n\n\n函数式编程的优点\n\n代码简洁，开发快速\n接近自然语言，易于理解\n更方便代码管理\n易于“并发编程”\n代码的热升级\n\n函数式编程基础\nlodash\n纯函数\n函数柯里化\n\n在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n1234567// 简单的举例const add = (a, b) =&gt; a + b// Currying 后const curryingAdd = a =&gt; b =&gt; a + badd(1, 2) // 3curryingAdd(1)(2) // 3\n由此可以看出，柯里化一个函数，就是把原可以接收多个参数的函数变换成只接收单一参数，并用返回的函数接收余下的参数且返回结果的技术。\n1234567891011121314151617181920// 例：判断年龄基准值function checkAge (min, age) &#123;    return age &gt;= min&#125;// Currying 后function checkAge (min) &#123;    return function (age) &#123;        return age &gt;= min    &#125;&#125;// ES6 写法let checkAge = min =&gt; (age =&gt; age &gt;= min)let checkAge18 = checkAge(18)let checkAge20 = checkAge(20)checkAge18(16) // falsecheckAge18(20) // truecheckAge20(18) // falsecheckAge20(22) // true\n12345678910111213141516171819// 模拟实现 lodash 中的 curry 方法 （传入一个函数，把该函数转换为柯里化函数）const curry = fn =&gt; &#123;    return function curriedFn(...args) &#123;        if (args.length &lt; fn.length) &#123;            return function () &#123;                return curriedFn(...args.concat(Array.from(arguments)))            &#125;        &#125;        return fn(...args)    &#125;&#125;const getSum = (a, b, c) =&gt; (a + b + c)const curried = curry(getSum)curried(1, 2, 3) // 6curried(1, 2)(3) // 6curried(1)(2, 3) // 6curried(1)(2)(3) // 6\n总结\n\n\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n\n\n这是一种对函数参数的‘缓存’\n\n\n让函数变得更灵活，让函数的粒度更小\n\n\n可以把多元函数转换成一元函数，可以组合使用，产生强大的功能\n\n\n12345678910111213141516171819面试题：// 实现一个add方法，使计算结果能够满足如下预期：// add(1)(2)(3) = 6;// add(1, 2, 3)(4) = 10;// add(1)(2)(3)(4)(5) = 15;const add = (...rest) =&gt; &#123;    const fn = (...args) =&gt; &#123;        rest.push(...args)        return fn    &#125;    fn.toString = () =&gt; rest.reduce((total, num) =&gt; total + num, 0)    return fn&#125;console.log(+add(1)(2)(3)) // 6console.log(+add(1, 2, 3)(4)) // 10console.log(+add(1)(2)(3)(4)(5)) // 15\n管道\n组合函数\n\n\n函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间的过程函数合并成一个函数\n\n\n函数组合默认是从右到左执行\n\n\n123456789101112131415161718192021// 实现一个组合函数function compose (...args) &#123;    return function (value) &#123;        return args.reverse().reduce(function (acc, fn) &#123;            return fn(acc)        &#125;, value)    &#125;&#125;// ES6改造一下const compose = (...args) =&gt; value =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), value)// 测试const fn1 = arr =&gt; arr.reverse()const fn2 = arr =&gt; arr[0]const fn3 = str =&gt; str.toUpperCase()const f = compose(fn3, fn2, fn1)// const f = compose(compose(fn3, fn2), fn1)// const f = compose(fn3, compose(fn2, fn1))console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])) // THREE\n\n函数组合要满足结合律(associativity)\n\n我们既可以把 a 和 b 组合，还可以把 b 和 c 组合，结果都是一样的\n1234// 结合律let f = compose(a, b, c)compose(compose(a, b), c) == compose(a, compose(b, c))// true\n\n组合函数的调试\n\n123456789const _ = require(&#x27;lodash&#x27;)// 需要写一个辅助函数做调试const trace = _.curry((tag, v) =&gt; &#123;    console.log(tag, v)    return v&#125;)// 将此辅助函数插入到组合函数中即可compose(a, trace(&#x27;我在b之后&#x27;)， b, trace(&#x27;我在c之后&#x27;), c)\nPoint Free模式\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数\n\n不需要指明处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数\n\n案例演示\n123456789101112// Hello World =&gt; hello_world// 非 Point Free 模式function f (str) &#123;    return str.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;)&#125;// Point Freeconst fp = require(&#x27;lodash/fp&#x27;)const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;_&#x27;), fp.toLower)console.log(f(&#x27;Hello World&#x27;)) // hello_world\n函子\nFunctor\nMayBe\nEither\nIO\nTask\nfolktale\nMonad\n","plink":"https://rdhuang.gitee.io/2021/11/30/函数式编程/"}]