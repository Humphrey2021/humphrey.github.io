{"title":"函数式编程","date":"2021-11-30T14:25:34.000Z","date_formatted":{"ll":"Nov 30, 2021","L":"11/30/2021","MM-DD":"11-30"},"link":"2021/11/30/函数式编程","tags":["javascript","函数式编程"],"categories":["前端"],"updated":"2021-11-30T14:26:01.761Z","content":"<!-- ## 为什么要学函数式编程？\n\n - 随着 React 的流行受到越来越多的关注\n - Vue3也开始拥抱函数式编程\n - 函数式编程可以抛弃 this\n - 打包过程中可以更好的利用 tree shaking 过滤无用代码\n - 方便测试，方便并行处理\n - 有很多库可以帮助我们进行函数式开发：lodash, undersoore, ramda -->\n<h2 id=\"函数式编程概念\">函数式编程概念<a title=\"#函数式编程概念\" href=\"#函数式编程概念\"></a></h2>\n<p><a href=\"https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/4035031?fr=aladdin\" target=\"_blank\">函数式编程</a>（Functional Programming, FP）是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。<br>\n它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 就是对运算过程进行抽象，函数式编程中函数指的不是程序中的函数（方法），而是数学中的函数即映射关系。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = num1 + num2</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span> (<span class=\"params\">n1, n2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n1 + n2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sum = add(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum)</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数式编程的特性\">函数式编程的特性<a title=\"#函数式编程的特性\" href=\"#函数式编程的特性\"></a></h2>\n<ul>\n<li>\n<p><strong>函数是“第一等公民（first class）”</strong><br>\n<em>&quot;第一等公民&quot;指的是函数与其他数据类型一样，处于平等地位,可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</em></p>\n<ul>\n<li><strong>函数可以赋值给其他变量</strong></li>\n</ul>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fn = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我可以存储在变量中&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    index (posts) &#123; <span class=\"keyword\">return</span> Views.index(posts) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    index: Views.index</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>高阶函数(Higher-order function)</strong></p>\n<ul>\n<li><strong>可以把函数作为参数传递给另一个函数</strong></li>\n</ul>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// forEach</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forEach = <span class=\"function\">(<span class=\"params\">array, fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length; i ++) &#123;</span><br><span class=\"line\">        fn(array[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">forEach(arr, <span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(i) &#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>可以把函数作为另一个函数的返回结果</strong></li>\n</ul>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> once = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这里返回的函数如果写成箭头函数的话，会找不到 this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">            flag = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> pay = once(<span class=\"function\"><span class=\"params\">money</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">`支付了<span class=\"subst\">$&#123;money&#125;</span>元`</span>) &#125;)</span><br><span class=\"line\">pay(<span class=\"number\">5</span>)</span><br><span class=\"line\">pay(<span class=\"number\">5</span>)</span><br><span class=\"line\">pay(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>闭包(Closure)</strong><br>\n<em>函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包</em></p>\n<ul>\n<li>\n<p><strong>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员</strong></p>\n</li>\n<li>\n<p>本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，<strong>但是堆上的作用域成员因为被外部引用不能释放</strong>，因此内部函数依然可以访问外部函数的成员</p>\n</li>\n</ul>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 案例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makePower</span> (<span class=\"params\">power</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(number, power)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 优化写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> makePower = <span class=\"function\"><span class=\"params\">power</span> =&gt;</span> <span class=\"function\"><span class=\"params\">num</span> =&gt;</span> <span class=\"built_in\">Math</span>.pow(num, power)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> power2 = makePower(<span class=\"number\">2</span>) <span class=\"comment\">// 求平方</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> power3 = makePower(<span class=\"number\">3</span>) <span class=\"comment\">// 求立方</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(power2(<span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(power2(<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(power3(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>纯函数</strong></p>\n<ul>\n<li><strong>相同的输入永远会得到相同的输出</strong>, 而且没有任何可观察的副作用</li>\n</ul>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"comment\">// 纯函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不纯函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// [4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.splice(<span class=\"number\">0</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>惰性计算</strong><br>\n在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。</p>\n</li>\n<li>\n<p><strong>递归</strong><br>\nFP 还有一个特点是用递归做为控制流程的机制。</p>\n</li>\n<li>\n<p><strong>只用&quot;表达式&quot;，不用&quot;语句&quot;</strong></p>\n</li>\n<li>\n<p><strong>没有&quot;副作用&quot;</strong><br>\n所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>\n<p>函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>\n</li>\n<li>\n<p><strong>不修改状态</strong><br>\n函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>\n</li>\n<li>\n<p><strong>引用透明性</strong><br>\n函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。</p>\n</li>\n<li>\n<p><strong>副作用</strong><br>\n副作用是修改系统状态的语言结构。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。</p>\n</li>\n</ul>\n<h2 id=\"函数式编程的优点\">函数式编程的优点<a title=\"#函数式编程的优点\" href=\"#函数式编程的优点\"></a></h2>\n<ol>\n<li>代码简洁，开发快速</li>\n<li>接近自然语言，易于理解</li>\n<li>更方便代码管理</li>\n<li>易于“并发编程”</li>\n<li>代码的热升级</li>\n</ol>\n","plink":"https://rdhuang.gitee.io/2021/11/30/函数式编程/","toc":[{"id":"函数式编程概念","title":"函数式编程概念","index":"1"},{"id":"函数式编程的特性","title":"函数式编程的特性","index":"2"},{"id":"函数式编程的优点","title":"函数式编程的优点","index":"3"}],"copyright":{"author":"Humphrey","link":"<a href=\"https://rdhuang.gitee.io/2021/11/30/函数式编程/\" title=\"函数式编程\">https://rdhuang.gitee.io/2021/11/30/函数式编程/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}